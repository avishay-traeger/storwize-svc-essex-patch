diff --git a/Authors b/Authors
index 2653a63..8fdc536 100644
--- a/Authors
+++ b/Authors
@@ -19,6 +19,7 @@ Antony Messerli <ant@openstack.org>
 Armando Migliaccio <Armando.Migliaccio@eu.citrix.com>
 Arvind Somya <asomya@cisco.com>
 Asbj√∏rn Sannes <asbjorn.sannes@interhost.no>
+Avishay Traeger <avishay@il.ibm.com>
 Ben McGraw <ben@pistoncloud.com>
 Ben Swartzlander <bswartz@netapp.com>
 Bilal Akhtar <bilalakhtar@ubuntu.com>
@@ -173,6 +174,7 @@ Rick Harris <rconradharris@gmail.com>
 Rob Kost <kost@isi.edu>
 Robert Esker <esker@netapp.com>
 RongzeZhu <zrzhit@gmail.com>
+Ronen Kat <ronenkat@il.ibm.com>
 Russell Bryant <rbryant@redhat.com>
 Russell Sim <russell.sim@gmail.com>
 Ryan Lane <rlane@wikimedia.org>
diff --git a/etc/nova/nova.conf.sample b/etc/nova/nova.conf.sample
index b2607a9..5977408 100644
--- a/etc/nova/nova.conf.sample
+++ b/etc/nova/nova.conf.sample
@@ -1107,4 +1107,24 @@
 ###### (StrOpt) The ZFS path under which to create zvols for volumes.
 # san_zfs_volume_base="rpool/"
 
-# Total option count: 467
+######### defined in nova.volume.storwize_svc #########
+
+#### (StrOpt) Storage system storage pool for volumes
+# storwize_svc_volpool_name=volpool
+#### (StrOpt) Storage system space-efficiency parameter for volumes
+# storwize_svc_vol_rsize=2%
+#### (StrOpt) Storage system threshold for volume capacity warnings
+# storwize_svc_vol_warning=0
+#### (BoolOpt) Storage system autoexpand parameter for volumes (True/False)
+# storwize_svc_vol_autoexpand=True
+#### (StrOpt) Storage system grain size parameter for volumes (32/64/128/256)
+# storwize_svc_vol_grainsize=256
+#### (BoolOpt) Storage system compression option for volumes
+# storwize_svc_vol_compression=False
+#### (BoolOpt) Enable Easy Tier for volumes
+# storwize_svc_vol_easytier=true
+#### (StrOpt) Maximum number of seconds to wait for FlashCopy to be prepared. Maximum value is 600 seconds (10 minutes).
+# storwize_svc_flashcopy_timeout=120
+
+
+# Total option count: 475
diff --git a/nova/exception.py b/nova/exception.py
index 107d926..ba76b53 100644
--- a/nova/exception.py
+++ b/nova/exception.py
@@ -1029,3 +1029,7 @@ class InvalidInstanceIDMalformed(Invalid):
 
 class CouldNotFetchImage(NovaException):
     message = _("Could not fetch image %(image)s")
+
+class VolumeBackendAPIException(NovaException):
+    message = _("Bad or unexpected response from the storage volume "
+                "backend API: data=%(data)s")
diff --git a/nova/tests/test_storwize_svc.py b/nova/tests/test_storwize_svc.py
new file mode 100644
index 0000000..248bbc8
--- /dev/null
+++ b/nova/tests/test_storwize_svc.py
@@ -0,0 +1,1381 @@
+# vim: tabstop=4 shiftwidth=4 softtabstop=4
+
+# Copyright (c) 2012 IBM, Inc.
+# Copyright (c) 2012 OpenStack LLC.
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Authors:
+#   Ronen Kat <ronenkat@il.ibm.com>
+#   Avishay Traeger <avishay@il.ibm.com>
+
+"""
+Tests for the IBM Storwize V7000 and SVC volume driver.
+"""
+
+import random
+import socket
+
+from nova import exception
+from nova import log as logging
+from nova import test
+from nova import utils as excutils
+from nova.volume import storwize_svc
+
+LOG = logging.getLogger(__name__)
+
+
+class StorwizeSVCManagementSimulator:
+    def __init__(self, pool_name):
+        self._flags = {"storwize_svc_volpool_name": pool_name}
+        self._volumes_list = {}
+        self._hosts_list = {}
+        self._mappings_list = {}
+        self._fcmappings_list = {}
+        self._next_cmd_error = {
+            "lsportip": "",
+            "lsnodecanister": "",
+            "mkvdisk": "",
+            "lsvdisk": "",
+            "lsfcmap": "",
+            "prestartfcmap": "",
+            "startfcmap": "",
+            "rmfcmap": "",
+        }
+        self._errors = {
+            "CMMVC5701E": ("", "CMMVC5701E No object ID was specified."),
+            "CMMVC6035E": ("", "CMMVC6035E The action failed as the " +
+                               "object already exists."),
+            "CMMVC5753E": ("", "CMMVC5753E The specified object does not " +
+                               "exist or is not a suitable candidate."),
+            "CMMVC5707E": ("", "CMMVC5707E Required parameters are missing."),
+            "CMMVC6581E": ("", "CMMVC6581E The command has failed because " +
+                               "the maximum number of allowed iSCSI " +
+                               "qualified names (IQNs) has been reached, " +
+                               "or the IQN is already assigned or is not " +
+                               "valid."),
+            "CMMVC5754E": ("", "CMMVC5754E The specified object does not " +
+                               "exist, or the name supplied does not meet " +
+                               "the naming rules."),
+            "CMMVC6071E": ("", "CMMVC6071E The VDisk-to-host mapping was " +
+                               "not created because the VDisk is already " +
+                               "mapped to a host."),
+            "CMMVC5879E": ("", "CMMVC5879E The VDisk-to-host mapping was " +
+                               "not created because a VDisk is already " +
+                               "mapped to this host with this SCSI LUN."),
+            "CMMVC5840E": ("", "CMMVC5840E The virtual disk (VDisk) was " +
+                               "not deleted because it is mapped to a " +
+                               "host or because it is part of a FlashCopy " +
+                               "or Remote Copy mapping, or is involved in " +
+                               "an image mode migrate."),
+            "CMMVC6527E": ("", "CMMVC6527E The name that you have entered " +
+                               "is not valid. The name can contain letters, " +
+                               "numbers, spaces, periods, dashes, and " +
+                               "underscores. The name must begin with a " +
+                               "letter or an underscore. The name must not " +
+                               "begin or end with a space."),
+            "CMMVC5871E": ("", "CMMVC5871E The action failed because one or " +
+                               "more of the configured port names is in a " +
+                               "mapping."),
+            "CMMVC5924E": ("", "CMMVC5924E The FlashCopy mapping was not " +
+                               "created because the source and target " +
+                               "virtual disks (VDisks) are different sizes."),
+            "CMMVC6303E": ("", "CMMVC6303E The create failed because the " +
+                               "source and target VDisks are the same."),
+            "CMMVC7050E": ("", "CMMVC7050E The command failed because at " +
+                               "least one node in the I/O group does not " +
+                               "support compressed VDisks."),
+        }
+
+    # Find an unused ID
+    def _find_unused_id(self, d):
+        ids = []
+        for k, v in d.iteritems():
+            ids.append(int(v["id"]))
+        ids.sort()
+        for index, n in enumerate(ids):
+            if n > index:
+                return str(index)
+        return str(len(ids))
+
+    # Check if name is valid
+    def _is_invalid_name(self, name):
+        if (name[0] == " ") or (name[-1] == " "):
+            return True
+        for c in name:
+            if ((not c.isalnum()) and (c != " ") and (c != ".")
+                    and (c != "-") and (c != "_")):
+                return True
+        return False
+
+    # Convert argument string to dictionary
+    def _cmd_to_dict(self, cmd):
+        arg_list = cmd.split()
+        no_param_args = [
+            "autodelete",
+            "autoexpand",
+            "bytes",
+            "compressed",
+            "force",
+            "nohdr",
+        ]
+        one_param_args = [
+            "cleanrate",
+            "delim",
+            "filtervalue",
+            "grainsize",
+            "host",
+            "iogrp",
+            "iscsiname",
+            "mdiskgrp",
+            "name",
+            "rsize",
+            "scsi",
+            "size",
+            "source",
+            "target",
+            "unit",
+            "easytier",
+            "warning",
+        ]
+
+        # Handle the special case of lsnode which is a two-word command
+        # Use the one word version of the command internally
+        if arg_list[0] == "svcinfo" and arg_list[1] == "lsnode":
+            ret = {"cmd": "lsnodecanister"}
+            arg_list.pop(0)
+        else:
+            ret = {"cmd": arg_list[0]}
+
+        skip = False
+        for i in range(1, len(arg_list)):
+            if skip:
+                skip = False
+                continue
+            if arg_list[i][0] == "-":
+                if arg_list[i][1:] in no_param_args:
+                    ret[arg_list[i][1:]] = True
+                elif arg_list[i][1:] in one_param_args:
+                    ret[arg_list[i][1:]] = arg_list[i + 1]
+                    skip = True
+                else:
+                    raise exception.InvalidInput(
+                        reason=_('unrecognized argument %s') % arg_list[i])
+            else:
+                ret["obj"] = arg_list[i]
+        return ret
+
+    # Generic function for printing information
+    def _print_info_cmd(self, rows, delim=" ", nohdr=False, **kwargs):
+        if nohdr:
+                del rows[0]
+
+        for index in range(len(rows)):
+            rows[index] = delim.join(rows[index])
+        return ("%s" % "\n".join(rows), "")
+
+    # Print mostly made-up stuff in the correct syntax
+    def _cmd_lsmdiskgrp(self, **kwargs):
+        rows = [None] * 3
+        rows[0] = ["id", "name", "status", "mdisk_count",
+                   "vdisk_count capacity", "extent_size", "free_capacity",
+                   "virtual_capacity", "used_capacity", "real_capacity",
+                   "overallocation", "warning", "easy_tier",
+                   "easy_tier_status"]
+        rows[1] = ["1", self._flags["storwize_svc_volpool_name"], "online",
+                   "1", str(len(self._volumes_list)), "3.25TB", "256",
+                   "3.21TB", "1.54TB", "264.97MB", "35.58GB", "47", "80",
+                   "auto", "inactive"]
+        rows[2] = ["2", "volpool2", "online",
+                   "1", "0", "3.25TB", "256",
+                   "3.21TB", "1.54TB", "264.97MB", "35.58GB", "47", "80",
+                   "auto", "inactive"]
+        return self._print_info_cmd(rows=rows, **kwargs)
+
+    # Print mostly made-up stuff in the correct syntax
+    def _cmd_lsnodecanister(self, **kwargs):
+        rows = [None] * 3
+        rows[0] = ["id", "name", "UPS_serial_number", "WWNN", "status",
+                   "IO_group_id", "IO_group_name", "config_node",
+                   "UPS_unique_id", "hardware", "iscsi_name", "iscsi_alias",
+                   "panel_name", "enclosure_id", "canister_id",
+                   "enclosure_serial_number"]
+        rows[1] = ["5", "node1", "", "123456789ABCDEF0", "online", "0",
+                   "io_grp0",
+                   "yes", "123456789ABCDEF0", "100",
+                   "iqn.1982-01.com.ibm:1234.sim.node1", "", "01-1", "1", "1",
+                   "0123ABC"]
+        rows[2] = ["6", "node2", "", "123456789ABCDEF1", "online", "0",
+                   "io_grp0",
+                   "no", "123456789ABCDEF1", "100",
+                   "iqn.1982-01.com.ibm:1234.sim.node2", "", "01-2", "1", "2",
+                   "0123ABC"]
+
+        if self._next_cmd_error["lsnodecanister"] == "header_mismatch":
+            rows[0].pop(2)
+            self._next_cmd_error["lsnodecanister"] = ""
+        if self._next_cmd_error["lsnodecanister"] == "remove_field":
+            for row in rows:
+                row.pop(0)
+            self._next_cmd_error["lsnodecanister"] = ""
+
+        return self._print_info_cmd(rows=rows, **kwargs)
+
+    # Print mostly made-up stuff in the correct syntax
+    def _cmd_lsportip(self, **kwargs):
+        if self._next_cmd_error["lsportip"] == "ip_no_config":
+            self._next_cmd_error["lsportip"] = ""
+            ip_addr1 = ""
+            ip_addr2 = ""
+            gw = ""
+        else:
+            ip_addr1 = "1.234.56.78"
+            ip_addr2 = "1.234.56.79"
+            gw = "1.234.56.1"
+
+        rows = [None] * 17
+        rows[0] = ["id", "node_id", "node_name", "IP_address", "mask",
+                   "gateway", "IP_address_6", "prefix_6", "gateway_6", "MAC",
+                   "duplex", "state", "speed", "failover"]
+        rows[1] = ["1", "5", "node1", ip_addr1, "255.255.255.0",
+                   gw, "", "", "", "01:23:45:67:89:00", "Full",
+                   "online", "1Gb/s", "no"]
+        rows[2] = ["1", "5", "node1", "", "", "", "", "", "",
+                   "01:23:45:67:89:00", "Full", "online", "1Gb/s", "yes"]
+        rows[3] = ["2", "5", "node1", "", "", "", "", "", "",
+                   "01:23:45:67:89:01", "Full", "unconfigured", "1Gb/s", "no"]
+        rows[4] = ["2", "5", "node1", "", "", "", "", "", "",
+                   "01:23:45:67:89:01", "Full", "unconfigured", "1Gb/s", "yes"]
+        rows[5] = ["3", "5", "node1", "", "", "", "", "", "", "", "",
+                   "unconfigured", "", "no"]
+        rows[6] = ["3", "5", "node1", "", "", "", "", "", "", "", "",
+                   "unconfigured", "", "yes"]
+        rows[7] = ["4", "5", "node1", "", "", "", "", "", "", "", "",
+                   "unconfigured", "", "no"]
+        rows[8] = ["4", "5", "node1", "", "", "", "", "", "", "", "",
+                   "unconfigured", "", "yes"]
+        rows[9] = ["1", "6", "node2", ip_addr2, "255.255.255.0",
+                   gw, "", "", "", "01:23:45:67:89:02", "Full",
+                   "online", "1Gb/s", "no"]
+        rows[10] = ["1", "6", "node2", "", "", "", "", "", "",
+                    "01:23:45:67:89:02", "Full", "online", "1Gb/s", "yes"]
+        rows[11] = ["2", "6", "node2", "", "", "", "", "", "",
+                    "01:23:45:67:89:03", "Full", "unconfigured", "1Gb/s", "no"]
+        rows[12] = ["2", "6", "node2", "", "", "", "", "", "",
+                    "01:23:45:67:89:03", "Full", "unconfigured", "1Gb/s",
+                    "yes"]
+        rows[13] = ["3", "6", "node2", "", "", "", "", "", "", "", "",
+                    "unconfigured", "", "no"]
+        rows[14] = ["3", "6", "node2", "", "", "", "", "", "", "", "",
+                    "unconfigured", "", "yes"]
+        rows[15] = ["4", "6", "node2", "", "", "", "", "", "", "", "",
+                    "unconfigured", "", "no"]
+        rows[16] = ["4", "6", "node2", "", "", "", "", "", "", "", "",
+                    "unconfigured", "", "yes"]
+
+        if self._next_cmd_error["lsportip"] == "header_mismatch":
+            rows[0].pop(2)
+            self._next_cmd_error["lsportip"] = ""
+        if self._next_cmd_error["lsportip"] == "remove_field":
+            for row in rows:
+                row.pop(1)
+            self._next_cmd_error["lsportip"] = ""
+
+        return self._print_info_cmd(rows=rows, **kwargs)
+
+    # Create a vdisk
+    def _cmd_mkvdisk(self, **kwargs):
+        # We only save the id/uid, name, and size - all else will be made up
+        volume_info = {}
+        volume_info["id"] = self._find_unused_id(self._volumes_list)
+        volume_info["uid"] = ("ABCDEF" * 3) + ("0" * 14) + volume_info["id"]
+
+        if "name" in kwargs:
+            volume_info["name"] = kwargs["name"].strip('\'\"')
+        else:
+            volume_info["name"] = "vdisk" + volume_info["id"]
+
+        # Assume size and unit are given, store it in bytes
+        capacity = int(kwargs["size"])
+        unit = kwargs["unit"]
+
+        if unit == "b":
+            cap_bytes = capacity
+        elif unit == "kb":
+            cap_bytes = capacity * pow(1024, 1)
+        elif unit == "mb":
+            cap_bytes = capacity * pow(1024, 2)
+        elif unit == "gb":
+            cap_bytes = capacity * pow(1024, 3)
+        elif unit == "tb":
+            cap_bytes = capacity * pow(1024, 4)
+        elif unit == "pb":
+            cap_bytes = capacity * pow(1024, 5)
+        volume_info["cap_bytes"] = str(cap_bytes)
+        volume_info["capacity"] = str(capacity) + unit.upper()
+
+        if "easytier" in kwargs:
+            if kwargs["easytier"] == "on":
+                volume_info["easy_tier"] = "on"
+            else:
+                volume_info["easy_tier"] = "off"
+
+        if "rsize" in kwargs:
+            # Fake numbers
+            volume_info["used_capacity"] = "0.75MB"
+            volume_info["real_capacity"] = "36.98MB"
+            volume_info["free_capacity"] = "36.23MB"
+            volume_info["used_capacity_bytes"] = "786432"
+            volume_info["real_capacity_bytes"] = "38776340"
+            volume_info["free_capacity_bytes"] = "37989908"
+            if "warning" in kwargs:
+                volume_info["warning"] = kwargs["warning"].rstrip('%')
+            else:
+                volume_info["warning"] = "80"
+            if "autoexpand" in kwargs:
+                volume_info["autoexpand"] = "on"
+            else:
+                volume_info["autoexpand"] = "off"
+            if "grainsize" in kwargs:
+                volume_info["grainsize"] = kwargs["grainsize"]
+            else:
+                volume_info["grainsize"] = "32"
+            if "compressed" in kwargs:
+                if self._next_cmd_error["mkvdisk"] == "no_compression":
+                    self._next_cmd_error["mkvdisk"] = ""
+                    return self._errors["CMMVC7050E"]
+                volume_info["compressed_copy"] = "yes"
+            else:
+                volume_info["compressed_copy"] = "no"
+        else:
+            volume_info["used_capacity"] = volume_info["capacity"]
+            volume_info["real_capacity"] = volume_info["capacity"]
+            volume_info["free_capacity"] = "0.00MB"
+            volume_info["used_capacity_bytes"] = volume_info["cap_bytes"]
+            volume_info["real_capacity_bytes"] = volume_info["cap_bytes"]
+            volume_info["free_capacity_bytes"] = "0"
+            volume_info["warning"] = ""
+            volume_info["autoexpand"] = ""
+            volume_info["grainsize"] = ""
+            volume_info["compressed_copy"] = "no"
+
+        if volume_info["name"] in self._volumes_list:
+            return self._errors["CMMVC6035E"]
+        else:
+            self._volumes_list[volume_info["name"]] = volume_info
+            return ("Virtual Disk, id [%s], successfully created" %
+                    (volume_info["id"]), "")
+
+    # Delete a vdisk
+    def _cmd_rmvdisk(self, **kwargs):
+        force = 0
+        if "force" in kwargs:
+            force = 1
+
+        if "obj" not in kwargs:
+            return self._errors["CMMVC5701E"]
+        vol_name = kwargs["obj"].strip('\'\"')
+
+        if not vol_name in self._volumes_list:
+            return self._errors["CMMVC5753E"]
+
+        if force == 0:
+            for k, mapping in self._mappings_list.iteritems():
+                if mapping["vol"] == vol_name:
+                    return self._errors["CMMVC5840E"]
+            for k, fcmap in self._fcmappings_list.iteritems():
+                if ((fcmap["source"] == vol_name) or
+                        (fcmap["target"] == vol_name)):
+                    return self._errors["CMMVC5840E"]
+
+        del self._volumes_list[vol_name]
+        return ("", "")
+
+    def _get_fcmap_info(self, vol_name):
+        ret_vals = {
+            "fc_id": "",
+            "fc_name": "",
+            "fc_map_count": "0",
+        }
+        for k, fcmap in self._fcmappings_list.iteritems():
+            if ((fcmap["source"] == vol_name) or
+                    (fcmap["target"] == vol_name)):
+                ret_vals["fc_id"] = fcmap["id"]
+                ret_vals["fc_name"] = fcmap["name"]
+                ret_vals["fc_map_count"] = "1"
+        return ret_vals
+
+    # List information about vdisks
+    def _cmd_lsvdisk(self, **kwargs):
+        if "obj" not in kwargs:
+            rows = []
+            rows.append(["id", "name", "IO_group_id", "IO_group_name",
+                         "status", "mdisk_grp_id", "mdisk_grp_name",
+                         "capacity", "type", "FC_id", "FC_name", "RC_id",
+                         "RC_name", "vdisk_UID", "fc_map_count", "copy_count",
+                         "fast_write_state", "se_copy_count", "RC_change"])
+
+            for k, vol in self._volumes_list.iteritems():
+                if (("filtervalue" not in kwargs) or
+                        (kwargs["filtervalue"] == "name=" + vol["name"])):
+                    fcmap_info = self._get_fcmap_info(vol["name"])
+
+                    if "bytes" in kwargs:
+                        cap = vol["cap_bytes"]
+                    else:
+                        cap = vol["capacity"]
+                    rows.append([str(vol["id"]), vol["name"], "0", "io_grp0",
+                                "online", "0",
+                                self._flags["storwize_svc_volpool_name"],
+                                cap, "striped",
+                                fcmap_info["fc_id"], fcmap_info["fc_name"],
+                                "", "", vol["uid"],
+                                fcmap_info["fc_map_count"], "1", "empty",
+                                "1", "no"])
+
+            return self._print_info_cmd(rows=rows, **kwargs)
+
+        else:
+            if kwargs["obj"] not in self._volumes_list:
+                return self._errors["CMMVC5754E"]
+            vol = self._volumes_list[kwargs["obj"]]
+            fcmap_info = self._get_fcmap_info(vol["name"])
+            if "bytes" in kwargs:
+                cap = vol["cap_bytes"]
+                cap_u = vol["used_capacity_bytes"]
+                cap_r = vol["real_capacity_bytes"]
+                cap_f = vol["free_capacity_bytes"]
+            else:
+                cap = vol["capacity"]
+                cap_u = vol["used_capacity"]
+                cap_r = vol["real_capacity"]
+                cap_f = vol["free_capacity"]
+            rows = []
+
+            rows.append(["id", str(vol["id"])])
+            rows.append(["name", vol["name"]])
+            rows.append(["IO_group_id", "0"])
+            rows.append(["IO_group_name", "io_grp0"])
+            rows.append(["status", "online"])
+            rows.append(["mdisk_grp_id", "0"])
+            rows.append(["mdisk_grp_name",
+                    self._flags["storwize_svc_volpool_name"]])
+            rows.append(["capacity", cap])
+            rows.append(["type", "striped"])
+            rows.append(["formatted", "no"])
+            rows.append(["mdisk_id", ""])
+            rows.append(["mdisk_name", ""])
+            rows.append(["FC_id", fcmap_info["fc_id"]])
+            rows.append(["FC_name", fcmap_info["fc_name"]])
+            rows.append(["RC_id", ""])
+            rows.append(["RC_name", ""])
+            rows.append(["vdisk_UID", vol["uid"]])
+            rows.append(["throttling", "0"])
+
+            if self._next_cmd_error["lsvdisk"] == "blank_pref_node":
+                rows.append(["preferred_node_id", ""])
+                self._next_cmd_error["lsvdisk"] = ""
+            elif self._next_cmd_error["lsvdisk"] == "no_pref_node":
+                self._next_cmd_error["lsvdisk"] = ""
+            else:
+                rows.append(["preferred_node_id", "6"])
+            rows.append(["fast_write_state", "empty"])
+            rows.append(["cache", "readwrite"])
+            rows.append(["udid", ""])
+            rows.append(["fc_map_count", fcmap_info["fc_map_count"]])
+            rows.append(["sync_rate", "50"])
+            rows.append(["copy_count", "1"])
+            rows.append(["se_copy_count", "0"])
+            rows.append(["mirror_write_priority", "latency"])
+            rows.append(["RC_change", "no"])
+            rows.append(["used_capacity", cap_u])
+            rows.append(["real_capacity", cap_r])
+            rows.append(["free_capacity", cap_f])
+            rows.append(["autoexpand", vol["autoexpand"]])
+            rows.append(["warning", vol["warning"]])
+            rows.append(["grainsize", vol["grainsize"]])
+            rows.append(["easy_tier", vol["easy_tier"]])
+            rows.append(["compressed_copy", vol["compressed_copy"]])
+
+            if "nohdr" in kwargs:
+                for index in range(len(rows)):
+                    rows[index] = " ".join(rows[index][1:])
+
+            if "delim" in kwargs:
+                for index in range(len(rows)):
+                    rows[index] = kwargs["delim"].join(rows[index])
+
+            return ("%s" % "\n".join(rows), "")
+
+    # Make a host
+    def _cmd_mkhost(self, **kwargs):
+        host_info = {}
+        host_info["id"] = self._find_unused_id(self._hosts_list)
+
+        if "name" in kwargs:
+            host_name = kwargs["name"].strip('\'\"')
+        else:
+            host_name = "host" + str(host_info["id"])
+        host_info["host_name"] = host_name
+
+        if "iscsiname" not in kwargs:
+            return self._errors["CMMVC5707E"]
+        host_info["iscsi_name"] = kwargs["iscsiname"].strip('\'\"')
+
+        if self._is_invalid_name(host_name):
+            return self._errors["CMMVC6527E"]
+
+        if host_name in self._hosts_list:
+            return self._errors["CMMVC6035E"]
+
+        for k, v in self._hosts_list.iteritems():
+            if v["iscsi_name"] == host_info["iscsi_name"]:
+                return self._errors["CMMVC6581E"]
+
+        self._hosts_list[host_name] = host_info
+        return ("Host, id [%s], successfully created" %
+                (host_info["id"]), "")
+
+    # Remove a host
+    def _cmd_rmhost(self, **kwargs):
+        if "obj" not in kwargs:
+            return self._errors["CMMVC5701E"]
+
+        host_name = kwargs["obj"].strip('\'\"')
+        if host_name not in self._hosts_list:
+            return self._errors["CMMVC5753E"]
+
+        for k, v in self._mappings_list.iteritems():
+            if (v["host"] == host_name):
+                return self._errors["CMMVC5871E"]
+
+        del self._hosts_list[host_name]
+        return ("", "")
+
+    # List information about hosts
+    def _cmd_lshost(self, **kwargs):
+        if "obj" not in kwargs:
+            rows = []
+            rows.append(["id", "name", "port_count", "iogrp_count", "status"])
+
+            found = False
+            for k, host in self._hosts_list.iteritems():
+                filterstr = "name=" + host["host_name"]
+                if (("filtervalue" not in kwargs) or
+                        (kwargs["filtervalue"] == filterstr)):
+                    rows.append([host["id"], host["host_name"], "1", "4",
+                                "offline"])
+                    found = True
+            if found:
+                return self._print_info_cmd(rows=rows, **kwargs)
+            else:
+                return ("", "")
+        else:
+            if kwargs["obj"] not in self._hosts_list:
+                return self._errors["CMMVC5754E"]
+            host = self._hosts_list[kwargs["obj"]]
+            rows = []
+            rows.append(["id", host["id"]])
+            rows.append(["name", host["host_name"]])
+            rows.append(["port_count", "1"])
+            rows.append(["type", "generic"])
+            rows.append(["mask", "1111"])
+            rows.append(["iogrp_count", "4"])
+            rows.append(["status", "offline"])
+            rows.append(["iscsi_name", host["iscsi_name"]])
+            rows.append(["node_logged_in_count", "0"])
+            rows.append(["state", "offline"])
+
+            if "nohdr" in kwargs:
+                for index in range(len(rows)):
+                    rows[index] = " ".join(rows[index][1:])
+
+            if "delim" in kwargs:
+                for index in range(len(rows)):
+                    rows[index] = kwargs["delim"].join(rows[index])
+
+            return ("%s" % "\n".join(rows), "")
+
+    # Create a vdisk-host mapping
+    def _cmd_mkvdiskhostmap(self, **kwargs):
+        mapping_info = {}
+        mapping_info["id"] = self._find_unused_id(self._mappings_list)
+
+        if "host" not in kwargs:
+            return self._errors["CMMVC5707E"]
+        mapping_info["host"] = kwargs["host"].strip('\'\"')
+
+        if "scsi" not in kwargs:
+            return self._errors["CMMVC5707E"]
+        mapping_info["lun"] = kwargs["scsi"].strip('\'\"')
+
+        if "obj" not in kwargs:
+            return self._errors["CMMVC5707E"]
+        mapping_info["vol"] = kwargs["obj"].strip('\'\"')
+
+        if not mapping_info["vol"] in self._volumes_list:
+            return self._errors["CMMVC5753E"]
+
+        if not mapping_info["host"] in self._hosts_list:
+            return self._errors["CMMVC5754E"]
+
+        if mapping_info["vol"] in self._mappings_list:
+            return self._errors["CMMVC6071E"]
+
+        for k, v in self._mappings_list.iteritems():
+            if ((v["host"] == mapping_info["host"]) and
+                    (v["lun"] == mapping_info["lun"])):
+                return self._errors["CMMVC5879E"]
+
+        self._mappings_list[mapping_info["vol"]] = mapping_info
+        return ("Virtual Disk to Host map, id [%s], successfully created"
+                % (mapping_info["id"]), "")
+
+    # Delete a vdisk-host mapping
+    def _cmd_rmvdiskhostmap(self, **kwargs):
+        if "host" not in kwargs:
+            return self._errors["CMMVC5707E"]
+        host = kwargs["host"].strip('\'\"')
+
+        if "obj" not in kwargs:
+            return self._errors["CMMVC5701E"]
+        vol = kwargs["obj"].strip('\'\"')
+
+        if not vol in self._mappings_list:
+            return self._errors["CMMVC5753E"]
+
+        if self._mappings_list[vol]["host"] != host:
+            return self._errors["CMMVC5753E"]
+
+        del self._mappings_list[vol]
+        return ("", "")
+
+    # List information about vdisk-host mappings
+    def _cmd_lshostvdiskmap(self, **kwargs):
+        index = 1
+        no_hdr = 0
+        delimeter = ""
+        host_name = kwargs["obj"]
+
+        if host_name not in self._hosts_list:
+            return self._errors["CMMVC5754E"]
+
+        rows = []
+        rows.append(["id", "name", "SCSI_id", "vdisk_id", "vdisk_name",
+                     "vdisk_UID"])
+
+        for k, mapping in self._mappings_list.iteritems():
+            if (host_name == "") or (mapping["host"] == host_name):
+                volume = self._volumes_list[mapping["vol"]]
+                rows.append([mapping["id"], mapping["host"],
+                            mapping["lun"], volume["id"],
+                            volume["name"], volume["uid"]])
+
+        return self._print_info_cmd(rows=rows, **kwargs)
+
+    # Create a FlashCopy mapping
+    def _cmd_mkfcmap(self, **kwargs):
+        source = ""
+        target = ""
+
+        if "source" not in kwargs:
+            return self._errors["CMMVC5707E"]
+        source = kwargs["source"].strip('\'\"')
+        if not source in self._volumes_list:
+            return self._errors["CMMVC5754E"]
+
+        if "target" not in kwargs:
+            return self._errors["CMMVC5707E"]
+        target = kwargs["target"].strip('\'\"')
+        if not target in self._volumes_list:
+            return self._errors["CMMVC5754E"]
+
+        if source == target:
+            return self._errors["CMMVC6303E"]
+
+        if (self._volumes_list[source]["cap_bytes"] !=
+                self._volumes_list[target]["cap_bytes"]):
+            return self._errors["CMMVC5924E"]
+
+        fcmap_info = {}
+        fcmap_info["source"] = source
+        fcmap_info["target"] = target
+        fcmap_info["id"] = self._find_unused_id(self._fcmappings_list)
+        fcmap_info["name"] = "fcmap" + fcmap_info["id"]
+        fcmap_info["status"] = "idle_or_copied"
+        fcmap_info["progress"] = "0"
+        self._fcmappings_list[target] = fcmap_info
+
+        return("FlashCopy Mapping, id [" + fcmap_info["id"] +
+               "], successfully created", "")
+
+    # Same function used for both prestartfcmap and startfcmap
+    def _cmd_gen_startfcmap(self, mode, **kwargs):
+        if "obj" not in kwargs:
+            return self._errors["CMMVC5701E"]
+        id_num = kwargs["obj"]
+
+        if mode == "pre":
+            if self._next_cmd_error["prestartfcmap"] == "bad_id":
+                id_num = -1
+                self._next_cmd_error["prestartfcmap"] = ""
+        else:
+            if self._next_cmd_error["startfcmap"] == "bad_id":
+                id_num = -1
+                self._next_cmd_error["startfcmap"] = ""
+
+        for k, fcmap in self._fcmappings_list.iteritems():
+            if fcmap["id"] == id_num:
+                if mode == "pre":
+                    fcmap["status"] = "preparing"
+                else:
+                    fcmap["status"] = "copying"
+                fcmap["progress"] = "0"
+                return ("", "")
+        return self._errors["CMMVC5753E"]
+
+    # Same function used for both stopfcmap and rmfcmap
+    # Assumes it is called with "-force <fc_map_id>"
+    def _cmd_stoprmfcmap(self, mode, **kwargs):
+        if "obj" not in kwargs:
+            return self._errors["CMMVC5701E"]
+        id_num = kwargs["obj"]
+
+        if self._next_cmd_error["rmfcmap"] == "bad_id":
+            id_num = -1
+            self._next_cmd_error["rmfcmap"] = ""
+
+        to_delete = None
+        found = False
+        for k, fcmap in self._fcmappings_list.iteritems():
+            if fcmap["id"] == id_num:
+                found = True
+                if mode == "rm":
+                    to_delete = k
+
+        if to_delete:
+            del self._fcmappings_list[to_delete]
+
+        if found:
+            return ("", "")
+        else:
+            return self._errors["CMMVC5753E"]
+
+    def _cmd_lsfcmap(self, **kwargs):
+        rows = []
+        rows.append(["id", "name", "source_vdisk_id", "source_vdisk_name",
+                     "target_vdisk_id", "target_vdisk_name", "group_id",
+                     "group_name", "status", "progress", "copy_rate",
+                     "clean_progress", "incremental", "partner_FC_id",
+                     "partner_FC_name", "restoring", "start_time",
+                     "rc_controlled"])
+
+        # Assume we always get a filtervalue argument
+        filter_key = kwargs["filtervalue"].split("=")[0]
+        filter_value = kwargs["filtervalue"].split("=")[1]
+        to_delete = []
+        for k, v in self._fcmappings_list.iteritems():
+            if str(v[filter_key]) == filter_value:
+                source = self._volumes_list[v["source"]]
+                target = self._volumes_list[v["target"]]
+                old_status = v["status"]
+                if old_status == "preparing":
+                    new_status = "prepared"
+                    if self._next_cmd_error["lsfcmap"] == "bogus_prepare":
+                        new_status = "bogus"
+                elif (old_status == "copying") and (v["progress"] == "0"):
+                    new_status = "copying"
+                    v["progress"] = "50"
+                elif (old_status == "copying") and (v["progress"] == "50"):
+                    new_status = "idle_or_copied"
+                    to_delete.append(k)
+                else:
+                    new_status = old_status
+                v["status"] = new_status
+
+                if ((self._next_cmd_error["lsfcmap"] == "speed_up") or
+                        (self._next_cmd_error["lsfcmap"] == "bogus_prepare")):
+                    print_status = new_status
+                    self._next_cmd_error["lsfcmap"] = ""
+                else:
+                    print_status = old_status
+
+                rows.append([v["id"], v["name"], source["id"],
+                            source["name"], target["id"], target["name"], "",
+                            "", print_status, v["progress"], "50", "100",
+                            "off", "", "", "no", "", "no"])
+
+        for d in to_delete:
+            del self._fcmappings_list[k]
+
+        return self._print_info_cmd(rows=rows, **kwargs)
+
+    # The main function to run commands on the management simulator
+    def execute_command(self, cmd, check_exit_code=True):
+        try:
+            kwargs = self._cmd_to_dict(cmd)
+        except IndexError:
+            return self._errors["CMMVC5707E"]
+
+        command = kwargs["cmd"]
+        del kwargs["cmd"]
+        arg_list = cmd.split()
+
+        if command == "lsmdiskgrp":
+            out, err = self._cmd_lsmdiskgrp(**kwargs)
+        elif command == "lsnodecanister":
+            out, err = self._cmd_lsnodecanister(**kwargs)
+        elif command == "lsportip":
+            out, err = self._cmd_lsportip(**kwargs)
+        elif command == "mkvdisk":
+            out, err = self._cmd_mkvdisk(**kwargs)
+        elif command == "rmvdisk":
+            out, err = self._cmd_rmvdisk(**kwargs)
+        elif command == "lsvdisk":
+            out, err = self._cmd_lsvdisk(**kwargs)
+        elif command == "mkhost":
+            out, err = self._cmd_mkhost(**kwargs)
+        elif command == "rmhost":
+            out, err = self._cmd_rmhost(**kwargs)
+        elif command == "lshost":
+            out, err = self._cmd_lshost(**kwargs)
+        elif command == "mkvdiskhostmap":
+            out, err = self._cmd_mkvdiskhostmap(**kwargs)
+        elif command == "rmvdiskhostmap":
+            out, err = self._cmd_rmvdiskhostmap(**kwargs)
+        elif command == "lshostvdiskmap":
+            out, err = self._cmd_lshostvdiskmap(**kwargs)
+        elif command == "mkfcmap":
+            out, err = self._cmd_mkfcmap(**kwargs)
+        elif command == "prestartfcmap":
+            out, err = self._cmd_gen_startfcmap(mode="pre", **kwargs)
+        elif command == "startfcmap":
+            out, err = self._cmd_gen_startfcmap(mode="start", **kwargs)
+        elif command == "stopfcmap":
+            out, err = self._cmd_stoprmfcmap(mode="stop", **kwargs)
+        elif command == "rmfcmap":
+            out, err = self._cmd_stoprmfcmap(mode="rm", **kwargs)
+        elif command == "lsfcmap":
+            out, err = self._cmd_lsfcmap(**kwargs)
+        else:
+            out, err = ("", "ERROR: Unsupported command")
+
+        if (check_exit_code) and (len(err) != 0):
+            raise exception.ProcessExecutionError(exit_code=1,
+                                                  stdout=out,
+                                                  stderr=err,
+                                                  cmd=' '.join(cmd))
+
+        return (out, err)
+
+    # After calling this function, the next call to the specified command will
+    # result in in the error specified
+    def error_injection(self, cmd, error):
+        self._next_cmd_error[cmd] = error
+
+
+class StorwizeSVCFakeDriver(storwize_svc.StorwizeSVCDriver):
+    def __init__(self, *args, **kwargs):
+        super(StorwizeSVCFakeDriver, self).__init__(*args, **kwargs)
+
+    def set_fake_storage(self, fake):
+        self.fake_storage = fake
+
+    def _run_ssh(self, cmd, check_exit_code=True):
+        try:
+            LOG.debug(_('Run CLI command: %s') % cmd)
+            ret = self.fake_storage.execute_command(cmd, check_exit_code)
+            (stdout, stderr) = ret
+            LOG.debug(_('CLI output:\n stdout: %(out)s\n stderr: %(err)s') %
+                        {'out': stdout, 'err': stderr})
+
+        except exception.ProcessExecutionError as e:
+            with excutils.save_and_reraise_exception():
+                LOG.debug(_('CLI Exception output:\n stdout: %(out)s\n '
+                            'stderr: %(err)s') % {'out': e.stdout,
+                            'err': e.stderr})
+
+        return ret
+
+
+class StorwizeSVCDriverTestCase(test.TestCase):
+    def setUp(self):
+        super(StorwizeSVCDriverTestCase, self).setUp()
+        self.USESIM = 1
+        if self.USESIM == 1:
+            self.sim = StorwizeSVCManagementSimulator("volpool")
+            driver = StorwizeSVCFakeDriver()
+            driver.set_fake_storage(self.sim)
+            storwize_svc.FLAGS.san_ip = "hostname"
+            storwize_svc.FLAGS.san_login = "user"
+            storwize_svc.FLAGS.san_password = "pass"
+            storwize_svc.FLAGS.storwize_svc_flashcopy_timeout = "20"
+        else:
+            driver = storwize_svc.StorwizeSVCDriver()
+            storwize_svc.FLAGS.san_ip = "-1.-1.-1.-1"
+            storwize_svc.FLAGS.san_login = "user"
+            storwize_svc.FLAGS.san_password = "password"
+            storwize_svc.FLAGS.storwize_svc_volpool_name = "pool"
+
+        self.driver = driver
+        self.driver.do_setup(None)
+        self.driver.check_for_setup_error()
+
+    def _revert_flags(self):
+        for flag in storwize_svc.storwize_svc_opts:
+            setattr(storwize_svc.FLAGS, flag.name, flag.default)
+
+    def test_storwize_svc_volume_tests(self):
+        storwize_svc.FLAGS.storwize_svc_vol_rsize = "-1"
+        volume = {}
+        volume["name"] = "test1_volume%s" % random.randint(10000, 99999)
+        volume["size"] = 10
+        volume["id"] = 1
+        self.driver.create_volume(volume)
+        # Make sure that the volume has been created
+        is_volume_defined = self.driver._is_volume_defined(volume["name"])
+        self.assertEqual(is_volume_defined, True)
+        self.driver.delete_volume(volume)
+
+        if self.USESIM == 1:
+            storwize_svc.FLAGS.storwize_svc_vol_rsize = "2%"
+            storwize_svc.FLAGS.storwize_svc_vol_compression = True
+            self.driver.create_volume(volume)
+            is_volume_defined = self.driver._is_volume_defined(volume["name"])
+            self.assertEqual(is_volume_defined, True)
+            self.driver.delete_volume(volume)
+            self._revert_flags()
+
+    def test_storwize_svc_ip_connectivity(self):
+        # Check for missing san_ip
+        storwize_svc.FLAGS.san_ip = None
+        self.assertRaises(exception.InvalidInput,
+                self.driver._check_flags)
+        self._revert_flags()
+
+        if self.USESIM != 1:
+            # Check for invalid ip
+            storwize_svc.FLAGS.san_ip = "-1.-1.-1.-1"
+            self.assertRaises(socket.gaierror,
+                        self.driver.check_for_setup_error)
+
+            # Check for unreachable IP
+            storwize_svc.FLAGS.san_ip = "1.1.1.1"
+            self.assertRaises(socket.error,
+                        self.driver.check_for_setup_error)
+
+            self._revert_flags()
+
+    def test_storwize_svc_connectivity(self):
+        # Make sure we detect if the pool doesn't exist
+        orig_pool = getattr(storwize_svc.FLAGS, "storwize_svc_volpool_name")
+        no_exist_pool = "i-dont-exist-%s" % random.randint(10000, 99999)
+        storwize_svc.FLAGS.storwize_svc_volpool_name = no_exist_pool
+        self.assertRaises(exception.InvalidInput,
+                self.driver.check_for_setup_error)
+        storwize_svc.FLAGS.storwize_svc_volpool_name = orig_pool
+
+        # Check the case where the user didn't configure IP addresses
+        # as well as receiving unexpected results from the storage
+        if self.USESIM == 1:
+            self.sim.error_injection("lsnodecanister", "header_mismatch")
+            self.assertRaises(exception.VolumeBackendAPIException,
+                    self.driver.check_for_setup_error)
+            self.sim.error_injection("lsnodecanister", "remove_field")
+            self.assertRaises(exception.VolumeBackendAPIException,
+                    self.driver.check_for_setup_error)
+            self.sim.error_injection("lsportip", "ip_no_config")
+            self.assertRaises(exception.VolumeBackendAPIException,
+                    self.driver.check_for_setup_error)
+            self.sim.error_injection("lsportip", "header_mismatch")
+            self.assertRaises(exception.VolumeBackendAPIException,
+                    self.driver.check_for_setup_error)
+            self.sim.error_injection("lsportip", "remove_field")
+            self.assertRaises(exception.VolumeBackendAPIException,
+                    self.driver.check_for_setup_error)
+
+        # Check with bad parameters
+        storwize_svc.FLAGS.san_password = None
+        storwize_svc.FLAGS.san_private_key = None
+        self.assertRaises(exception.InvalidInput,
+                self.driver._check_flags)
+        self._revert_flags()
+
+        storwize_svc.FLAGS.storwize_svc_vol_rsize = "invalid"
+        self.assertRaises(exception.InvalidInput,
+                self.driver._check_flags)
+        self._revert_flags()
+
+        storwize_svc.FLAGS.storwize_svc_vol_warning = "invalid"
+        self.assertRaises(exception.InvalidInput,
+                self.driver._check_flags)
+        self._revert_flags()
+
+        storwize_svc.FLAGS.storwize_svc_vol_autoexpand = "invalid"
+        self.assertRaises(exception.InvalidInput,
+                self.driver._check_flags)
+        self._revert_flags()
+
+        storwize_svc.FLAGS.storwize_svc_vol_grainsize = str(42)
+        self.assertRaises(exception.InvalidInput,
+                self.driver._check_flags)
+        self._revert_flags()
+
+        storwize_svc.FLAGS.storwize_svc_flashcopy_timeout = str(601)
+        self.assertRaises(exception.InvalidInput,
+                self.driver._check_flags)
+        self._revert_flags()
+
+        storwize_svc.FLAGS.storwize_svc_vol_compression = True
+        storwize_svc.FLAGS.storwize_svc_vol_rsize = "-1"
+        self.assertRaises(exception.InvalidInput,
+                self.driver._check_flags)
+        self._revert_flags()
+
+        # Finally, check with good parameters
+        self.driver.check_for_setup_error()
+
+    def test_storwize_svc_flashcopy(self):
+        volume1 = {}
+        volume1["name"] = "test1_volume%s" % random.randint(10000, 99999)
+        volume1["size"] = 10
+        volume1["id"] = 10
+        self.driver.create_volume(volume1)
+
+        snapshot = {}
+        snapshot["name"] = "snap_volume%s" % random.randint(10000, 99999)
+        snapshot["volume_name"] = volume1["name"]
+
+        # Test timeout and volume cleanup
+        storwize_svc.FLAGS.storwize_svc_flashcopy_timeout = str(1)
+        self.assertRaises(exception.InvalidSnapshot,
+                self.driver.create_snapshot, snapshot)
+        is_volume_defined = self.driver._is_volume_defined(snapshot["name"])
+        self.assertEqual(is_volume_defined, False)
+        self._revert_flags()
+
+        # Test bogus statuses
+        if self.USESIM == 1:
+            self.sim.error_injection("lsfcmap", "bogus_prepare")
+            self.assertRaises(exception.VolumeBackendAPIException,
+                self.driver.create_snapshot, snapshot)
+
+        # Test prestartfcmap, startfcmap, and rmfcmap failing
+        if self.USESIM == 1:
+            self.sim.error_injection("prestartfcmap", "bad_id")
+            self.assertRaises(exception.ProcessExecutionError,
+                self.driver.create_snapshot, snapshot)
+            self.sim.error_injection("lsfcmap", "speed_up")
+            self.sim.error_injection("startfcmap", "bad_id")
+            self.assertRaises(exception.ProcessExecutionError,
+                self.driver.create_snapshot, snapshot)
+            self.sim.error_injection("prestartfcmap", "bad_id")
+            self.sim.error_injection("rmfcmap", "bad_id")
+            self.assertRaises(exception.ProcessExecutionError,
+                self.driver.create_snapshot, snapshot)
+
+        # Test successful snapshot
+        self.driver.create_snapshot(snapshot)
+
+        # Ensure snapshot is defined
+        is_volume_defined = self.driver._is_volume_defined(snapshot["name"])
+        self.assertEqual(is_volume_defined, True)
+
+        # Try to create a snapshot from an non-existing volume - should fail
+        snapshot2 = {}
+        snapshot2["name"] = "snap_volume%s" % random.randint(10000, 99999)
+        snapshot2["volume_name"] = "undefined-vol"
+        self.assertRaises(exception.VolumeNotFound,
+                          self.driver.create_snapshot,
+                          snapshot2)
+
+        # Create volume from snapshot
+        volume2 = {}
+        volume2["name"] = "snap2vol_volume%s" % random.randint(10000, 99999)
+
+        # Create volume from snapshot into an existsing volume
+        self.assertRaises(exception.InvalidSnapshot,
+                          self.driver.create_volume_from_snapshot,
+                          volume1,
+                          snapshot)
+
+        # Try to create a volume from a non-existing snapshot
+        self.assertRaises(exception.SnapshotNotFound,
+                          self.driver.create_volume_from_snapshot,
+                          volume2,
+                          snapshot2)
+
+        # Fail the snapshot
+        if self.USESIM == 1:
+            self.sim.error_injection("prestartfcmap", "bad_id")
+            self.assertRaises(exception.ProcessExecutionError,
+                self.driver.create_volume_from_snapshot, volume2, snapshot)
+
+        # Succeed
+        if self.USESIM == 1:
+            self.sim.error_injection("lsfcmap", "speed_up")
+        self.driver.create_volume_from_snapshot(volume2, snapshot)
+
+        # Ensure volume is defined
+        is_volume_defined = self.driver._is_volume_defined(volume2["name"])
+        self.assertEqual(is_volume_defined, True)
+
+        self.driver._delete_volume(volume2, True)
+        self.driver._delete_snapshot(snapshot, True)
+
+        # Check with target with different size
+        volume3 = {}
+        volume3["name"] = "test3_volume%s" % random.randint(10000, 99999)
+        volume3["size"] = 11
+        volume3["id"] = 11
+        self.driver.create_volume(volume3)
+        snapshot["name"] = volume3["name"]
+        self.assertRaises(exception.InvalidSnapshot,
+                self.driver.create_snapshot, snapshot)
+        self.driver._delete_volume(volume1, True)
+        self.driver._delete_volume(volume3, True)
+
+        # Snapshot volume that doesn't exist
+        snapshot = {}
+        snapshot["name"] = "snap_volume%s" % random.randint(10000, 99999)
+        snapshot["volume_name"] = "no_exist"
+        self.assertRaises(exception.VolumeNotFound,
+                self.driver.create_snapshot, snapshot)
+
+    def test_storwize_svc_volumes(self):
+        # Create a first volume
+        volume = {}
+        volume["name"] = "test1_volume%s" % random.randint(10000, 99999)
+        volume["size"] = 10
+        volume["id"] = 1
+
+        self.driver.create_volume(volume)
+
+        self.driver.ensure_export(None, volume)
+
+        # Do nothing
+        self.driver.create_export(None, volume)
+        self.driver.remove_export(None, volume)
+        self.assertRaises(NotImplementedError,
+                self.driver.check_for_export, None, volume["id"])
+
+        # Make sure volume attributes are as they should be
+        attributes = self.driver._get_volume_attributes(volume["name"])
+        attr_size = float(attributes["capacity"]) / 1073741824  # bytes to GB
+        self.assertEqual(attr_size, float(volume["size"]))
+        pool = getattr(storwize_svc.FLAGS, "storwize_svc_volpool_name")
+        self.assertEqual(attributes["mdisk_grp_name"], pool)
+
+        # Try to create the volume again (should fail)
+        self.assertRaises(exception.ProcessExecutionError,
+                self.driver.create_volume, volume)
+
+        # Try to delete a volume that doesn't exist (should not fail)
+        vol_no_exist = {"name": "i_dont_exist"}
+        self.driver.delete_volume(vol_no_exist)
+        # Ensure export for volume that doesn't exist (should not fail)
+        self.driver.ensure_export(None, vol_no_exist)
+
+        # Delete the volume
+        self.driver.delete_volume(volume)
+
+    def _create_test_vol(self):
+        volume = {}
+        volume["name"] = "testparam_volume%s" % random.randint(10000, 99999)
+        volume["size"] = 1
+        volume["id"] = 1
+        self.driver.create_volume(volume)
+
+        attrs = self.driver._get_volume_attributes(volume["name"])
+        self.driver.delete_volume(volume)
+        return attrs
+
+    def test_storwize_svc_volume_params(self):
+        # Option test matrix
+        # Option        Value   Covered by test #
+        # rsize         -1      1
+        # rsize         2%      2,3
+        # warning       0       2
+        # warning       80%     3
+        # autoexpand    True    2
+        # autoexpand    False   3
+        # grainsize     32      2
+        # grainsize     256     3
+        # compression   True    4
+        # compression   False   2,3
+        # easytier      True    1,3
+        # easytier      False   2
+
+        # Test 1
+        storwize_svc.FLAGS.storwize_svc_vol_rsize = "-1"
+        storwize_svc.FLAGS.storwize_svc_vol_easytier = True
+        attrs = self._create_test_vol()
+        self.assertEquals(attrs["free_capacity"], "0")
+        self.assertEquals(attrs["easy_tier"], "on")
+        self._revert_flags()
+
+        # Test 2
+        storwize_svc.FLAGS.storwize_svc_vol_rsize = "2%"
+        storwize_svc.FLAGS.storwize_svc_vol_compression = False
+        storwize_svc.FLAGS.storwize_svc_vol_warning = "0"
+        storwize_svc.FLAGS.storwize_svc_vol_autoexpand = True
+        storwize_svc.FLAGS.storwize_svc_vol_grainsize = "32"
+        storwize_svc.FLAGS.storwize_svc_vol_easytier = False
+        attrs = self._create_test_vol()
+        self.assertNotEqual(attrs["capacity"], attrs["real_capacity"])
+        self.assertEquals(attrs["compressed_copy"], "no")
+        self.assertEquals(attrs["warning"], "0")
+        self.assertEquals(attrs["autoexpand"], "on")
+        self.assertEquals(attrs["grainsize"], "32")
+        self.assertEquals(attrs["easy_tier"], "off")
+        self._revert_flags()
+
+        # Test 3
+        storwize_svc.FLAGS.storwize_svc_vol_rsize = "2%"
+        storwize_svc.FLAGS.storwize_svc_vol_compression = False
+        storwize_svc.FLAGS.storwize_svc_vol_warning = "80%"
+        storwize_svc.FLAGS.storwize_svc_vol_autoexpand = False
+        storwize_svc.FLAGS.storwize_svc_vol_grainsize = "256"
+        storwize_svc.FLAGS.storwize_svc_vol_easytier = True
+        attrs = self._create_test_vol()
+        self.assertNotEqual(attrs["capacity"], attrs["real_capacity"])
+        self.assertEquals(attrs["compressed_copy"], "no")
+        self.assertEquals(attrs["warning"], "80")
+        self.assertEquals(attrs["autoexpand"], "off")
+        self.assertEquals(attrs["grainsize"], "256")
+        self.assertEquals(attrs["easy_tier"], "on")
+        self._revert_flags()
+
+        # Test 4
+        storwize_svc.FLAGS.storwize_svc_vol_rsize = "2%"
+        storwize_svc.FLAGS.storwize_svc_vol_compression = True
+        try:
+            attrs = self._create_test_vol()
+            self.assertNotEqual(attrs["capacity"], attrs["real_capacity"])
+            self.assertEquals(attrs["compressed_copy"], "yes")
+        except exception.ProcessExecutionError as e:
+            if "CMMVC7050E" not in e.stderr:
+                raise exception.ProcessExecutionError(exit_code=e.exit_code,
+                                                      stdout=e.stdout,
+                                                      stderr=e.stderr,
+                                                      cmd=e.cmd)
+        if self.USESIM == 1:
+            self.sim.error_injection("mkvdisk", "no_compression")
+            self.assertRaises(exception.ProcessExecutionError,
+                    self._create_test_vol)
+        self._revert_flags()
+
+    def test_storwize_svc_unicode_host_and_volume_names(self):
+        volume1 = {}
+        volume1["name"] = u"unicode1_volume%s" % random.randint(10000, 99999)
+        volume1["size"] = 2
+        volume1["id"] = 1
+        self.driver.create_volume(volume1)
+        # Make sure that the volumes have been created
+        is_volume_defined = self.driver._is_volume_defined(volume1["name"])
+        self.assertEqual(is_volume_defined, True)
+        conn = {}
+        conn["initiator"] = u"unicode:init:%s" % random.randint(10000, 99999)
+        conn["ip"] = "10.10.10.10"  # Bogus ip for testing
+        self.driver.initialize_connection(volume1, conn)
+        self.driver.terminate_connection(volume1, conn)
+        self.driver.delete_volume(volume1)
+
+    def test_storwize_svc_host_maps(self):
+        # Create two volumes to be used in mappings
+        volume1 = {}
+        volume1["name"] = "test1_volume%s" % random.randint(10000, 99999)
+        volume1["size"] = 2
+        volume1["id"] = 1
+        self.driver.create_volume(volume1)
+        volume2 = {}
+        volume2["name"] = "test2_volume%s" % random.randint(10000, 99999)
+        volume2["size"] = 2
+        volume2["id"] = 1
+        self.driver.create_volume(volume2)
+
+        # Check case where no hosts exist
+        if self.USESIM == 1:
+            ret = self.driver._get_host_from_iscsiname("foo")
+            self.assertEquals(ret, None)
+            ret = self.driver._is_host_defined("foo")
+            self.assertEquals(ret, False)
+
+        # Make sure that the volumes have been created
+        is_volume_defined = self.driver._is_volume_defined(volume1["name"])
+        self.assertEqual(is_volume_defined, True)
+        is_volume_defined = self.driver._is_volume_defined(volume2["name"])
+        self.assertEqual(is_volume_defined, True)
+
+        # Initialize connection from the first volume to a host
+        # Add some characters to the initiator name that should be converted
+        # when used for the host name
+        conn = {}
+        conn["initiator"] = "test:init:%s" % random.randint(10000, 99999)
+        conn["ip"] = "10.10.10.10"  # Bogus ip for testing
+        self.driver.initialize_connection(volume1, conn)
+
+        # Initialize again, should notice it and do nothing
+        self.driver.initialize_connection(volume1, conn)
+
+        # Try to delete the 1st volume (should fail because it is mapped)
+        self.assertRaises(exception.ProcessExecutionError,
+                self.driver.delete_volume, volume1)
+
+        # Test no preferred node
+        self.driver.terminate_connection(volume1, conn)
+        if self.USESIM == 1:
+            self.sim.error_injection("lsvdisk", "no_pref_node")
+            self.driver.initialize_connection(volume1, conn)
+
+        # Initialize connection from the second volume to the host with no
+        # preferred node set if in simulation mode, otherwise, just
+        # another initialize connection.
+        if self.USESIM == 1:
+            self.sim.error_injection("lsvdisk", "blank_pref_node")
+        self.driver.initialize_connection(volume2, conn)
+
+        # Try to remove connection from host that doesn't exist (should fail)
+        conn_no_exist = {"initiator": "i_dont_exist"}
+        self.assertRaises(exception.VolumeBackendAPIException,
+                self.driver.terminate_connection, volume1, conn_no_exist)
+
+        # Try to remove connection from volume that isn't mapped (should print
+        # message but NOT fail)
+        vol_no_exist = {"name": "i_dont_exist"}
+        self.driver.terminate_connection(vol_no_exist, conn)
+
+        # Remove the mapping from the 1st volume and delete it
+        self.driver.terminate_connection(volume1, conn)
+        self.driver.delete_volume(volume1)
+        vol_def = self.driver._is_volume_defined(volume1["name"])
+        self.assertEqual(vol_def, False)
+
+        # Make sure our host still exists
+        host_name = self.driver._get_host_from_iscsiname(conn["initiator"])
+        host_def = self.driver._is_host_defined(host_name)
+        self.assertEquals(host_def, True)
+
+        # Remove the mapping from the 2nd volume and delete it. The host should
+        # be automatically removed because there are no more mappings.
+        self.driver.terminate_connection(volume2, conn)
+        self.driver.delete_volume(volume2)
+        vol_def = self.driver._is_volume_defined(volume2["name"])
+        self.assertEqual(vol_def, False)
+
+        # Check if our host still exists (it should not)
+        ret = self.driver._get_host_from_iscsiname(conn["initiator"])
+        self.assertEquals(ret, None)
+        ret = self.driver._is_host_defined(host_name)
+        self.assertEquals(ret, False)
diff --git a/nova/volume/storwize_svc.py b/nova/volume/storwize_svc.py
new file mode 100644
index 0000000..d3af93f
--- /dev/null
+++ b/nova/volume/storwize_svc.py
@@ -0,0 +1,1257 @@
+# vim: tabstop=4 shiftwidth=4 softtabstop=4
+
+# Copyright (c) 2012 IBM, Inc.
+# Copyright (c) 2012 OpenStack LLC.
+# All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License"); you may
+#    not use this file except in compliance with the License. You may obtain
+#    a copy of the License at
+#
+#         http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+#    License for the specific language governing permissions and limitations
+#    under the License.
+#
+# Authors:
+#   Ronen Kat <ronenkat@il.ibm.com>
+#   Avishay Traeger <avishay@il.ibm.com>
+
+"""
+Volume driver for IBM Storwize V7000 and SVC storage systems.
+
+Notes:
+1. If you specify both a password and a key file, this driver will use the
+   key file only.
+2. When using a key file for authentication, it is up to the user or
+   system administrator to store the private key in a safe manner.
+3. The defaults for creating volumes are "-rsize 2% -autoexpand
+   -grainsize 256 -warning 0".  These can be changed in the configuration
+   file or by using volume types(recommended only for advanced users).
+
+Limitations:
+1. The driver was not tested with SVC or clustered configurations of Storwize
+   V7000.
+2. The driver expects CLI output in English, error messages may be in a
+   localized format.
+"""
+
+import random
+import re
+import string
+import time
+
+from nova import exception
+from nova import flags
+from nova import log as logging
+from nova import utils as excutils
+from nova.openstack.common import cfg
+from nova.volume import san
+from nova import utils
+
+LOG = logging.getLogger(__name__)
+
+storwize_svc_opts = [
+    cfg.StrOpt('storwize_svc_volpool_name',
+               default='volpool',
+               help='Storage system storage pool for volumes'),
+    cfg.StrOpt('storwize_svc_vol_rsize',
+               default='2%',
+               help='Storage system space-efficiency parameter for volumes'),
+    cfg.StrOpt('storwize_svc_vol_warning',
+               default='0',
+               help='Storage system threshold for volume capacity warnings'),
+    cfg.BoolOpt('storwize_svc_vol_autoexpand',
+               default=True,
+               help='Storage system autoexpand parameter for volumes '
+                    '(True/False)'),
+    cfg.StrOpt('storwize_svc_vol_grainsize',
+               default='256',
+               help='Storage system grain size parameter for volumes '
+                    '(32/64/128/256)'),
+    cfg.BoolOpt('storwize_svc_vol_compression',
+               default=False,
+               help='Storage system compression option for volumes'),
+    cfg.BoolOpt('storwize_svc_vol_easytier',
+               default=True,
+               help='Enable Easy Tier for volumes'),
+    cfg.StrOpt('storwize_svc_flashcopy_timeout',
+               default='120',
+               help='Maximum number of seconds to wait for FlashCopy to be'
+                    'prepared. Maximum value is 600 seconds (10 minutes).'),
+]
+
+FLAGS = flags.FLAGS
+FLAGS.register_opts(storwize_svc_opts)
+
+
+class StorwizeSVCDriver(san.SanISCSIDriver):
+    """IBM Storwize V7000 and SVC iSCSI volume driver."""
+
+    def __init__(self, *args, **kwargs):
+        super(StorwizeSVCDriver, self).__init__(*args, **kwargs)
+        self.iscsi_ipv4_conf = None
+        self.iscsi_ipv6_conf = None
+
+        # Build cleanup transaltion tables for hosts names to follow valid
+        # host names for Storwizew V7000 and SVC storage systems.
+        invalid_ch_in_host = ''
+        for num in range(0, 128):
+            ch = chr(num)
+            if ((not ch.isalnum()) and (ch != ' ') and (ch != '.')
+                    and (ch != '-') and (ch != '_')):
+                invalid_ch_in_host = invalid_ch_in_host + ch
+        self._string_host_name_filter = string.maketrans(invalid_ch_in_host,
+                                                '-' * len(invalid_ch_in_host))
+
+        self._unicode_host_name_filter = dict((ord(unicode(char)), u'-')
+                                         for char in invalid_ch_in_host)
+
+    def _get_hdr_dic(self, header, row, delim):
+        """Return CLI row data as a dictionary indexed by names from header.
+
+        Create a dictionary object from the data row string using the header
+        string. The strings are converted to columns using the delimiter in
+        delim.
+        """
+
+        attributes = header.split(delim)
+        values = row.split(delim)
+        self._driver_assert(len(values) == len(attributes),
+            _('_get_hdr_dic: attribute headers and values do not match.\n '
+              'Headers: %(header)s\n Values: %(row)s')
+                % {'header': str(header),
+                   'row': str(row)})
+        dic = {}
+        for attribute, value in map(None, attributes, values):
+            dic[attribute] = value
+        return dic
+
+    def _driver_assert(self, assert_condition, exception_message):
+        """Internal assertion mechanism for CLI output."""
+        if not assert_condition:
+            LOG.error(exception_message)
+            raise exception.VolumeBackendAPIException(data=exception_message)
+
+    def check_for_setup_error(self):
+        """Check that we have all configuration details from the storage."""
+
+        LOG.debug(_('enter: check_for_setup_error'))
+
+        # Validate that the pool exists
+        ssh_cmd = 'lsmdiskgrp -delim ! -nohdr'
+        out, err = self._run_ssh(ssh_cmd)
+        self._driver_assert(len(out) > 0,
+            _('check_for_setup_error: failed with unexpected CLI output.\n '
+              'Command: %(cmd)s\n stdout: %(out)s\n stderr: %(err)s')
+                % {'cmd': ssh_cmd,
+                   'out': str(out),
+                   'err': str(err)})
+        search_text = '!%s!' % getattr(FLAGS, 'storwize_svc_volpool_name')
+        if search_text not in out:
+            raise exception.InvalidInput(
+                    reason=(_('pool %s doesn\'t exist')
+                        % getattr(FLAGS, 'storwize_svc_volpool_name')))
+
+        storage_nodes = {}
+        # Get the iSCSI names of the Storwize/SVC nodes
+        ssh_cmd = 'svcinfo lsnode -delim !'
+        out, err = self._run_ssh(ssh_cmd)
+        self._driver_assert(len(out) > 0,
+            _('check_for_setup_error: failed with unexpected CLI output.\n '
+              'Command: %(cmd)s\n stdout: %(out)s\n stderr: %(err)s')
+                % {'cmd': ssh_cmd,
+                   'out': str(out),
+                   'err': str(err)})
+
+        nodes = out.strip().split('\n')
+        self._driver_assert(len(nodes) > 0,
+            _('check_for_setup_error: failed with unexpected CLI output.\n '
+              'Command: %(cmd)s\n stdout: %(out)s\n stderr: %(err)s')
+                % {'cmd': ssh_cmd,
+                   'out': str(out),
+                   'err': str(err)})
+        header = nodes.pop(0)
+        for node_line in nodes:
+            try:
+                node_data = self._get_hdr_dic(header, node_line, '!')
+            except exception.VolumeBackendAPIException as e:
+                with excutils.save_and_reraise_exception():
+                    LOG.error(_('check_for_setup_error: '
+                                'failed with unexpected CLI output.\n '
+                                'Command: %(cmd)s\n '
+                                'stdout: %(out)s\n stderr: %(err)s\n')
+                              % {'cmd': ssh_cmd,
+                                 'out': str(out),
+                                 'err': str(err)})
+            node = {}
+            try:
+                node['id'] = node_data['id']
+                node['name'] = node_data['name']
+                node['iscsi_name'] = node_data['iscsi_name']
+                node['status'] = node_data['status']
+                node['ipv4'] = []
+                node['ipv6'] = []
+                if node['iscsi_name'] != '':
+                    storage_nodes[node['id']] = node
+            except KeyError as e:
+                LOG.error(_('Did not find expected column name in '
+                            'svcinfo lsnode: %s') % str(e))
+                exception_message = (
+                    _('check_for_setup_error: Unexpected CLI output.\n '
+                      'Details: %(msg)s\n'
+                      'Command: %(cmd)s\n '
+                      'stdout: %(out)s\n stderr: %(err)s')
+                            % {'msg': str(e),
+                               'cmd': ssh_cmd,
+                               'out': str(out),
+                               'err': str(err)})
+                raise exception.VolumeBackendAPIException(
+                        data=exception_message)
+
+        # Get the iSCSI IP addresses of the Storwize/SVC nodes
+        ssh_cmd = 'lsportip -delim !'
+        out, err = self._run_ssh(ssh_cmd)
+        self._driver_assert(len(out) > 0,
+            _('check_for_setup_error: failed with unexpected CLI output.\n '
+              'Command: %(cmd)s\n '
+              'stdout: %(out)s\n stderr: %(err)s')
+                            % {'cmd': ssh_cmd,
+                               'out': str(out),
+                               'err': str(err)})
+
+        portips = out.strip().split('\n')
+        self._driver_assert(len(portips) > 0,
+            _('check_for_setup_error: failed with unexpected CLI output.\n '
+              'Command: %(cmd)s\n stdout: %(out)s\n stderr: %(err)s')
+                % {'cmd': ssh_cmd,
+                   'out': str(out),
+                   'err': str(err)})
+        header = portips.pop(0)
+        for portip_line in portips:
+            try:
+                port_data = self._get_hdr_dic(header, portip_line, '!')
+            except exception.VolumeBackendAPIException as e:
+                with excutils.save_and_reraise_exception():
+                    LOG.error(_('check_for_setup_error: '
+                                'failed with unexpected CLI output.\n '
+                                'Command: %(cmd)s\n '
+                                'stdout: %(out)s\n stderr: %(err)s\n')
+                              % {'cmd': ssh_cmd,
+                                 'out': str(out),
+                                 'err': str(err)})
+            try:
+                port_node_id = port_data['node_id']
+                port_ipv4 = port_data['IP_address']
+                port_ipv6 = port_data['IP_address_6']
+            except KeyError as e:
+                LOG.error(_('Did not find expected column name in '
+                            'lsportip: %s') % str(e))
+                exception_message = (
+                    _('check_for_setup_error: Unexpected CLI output.\n '
+                      'Details: %(msg)s\n'
+                      'Command: %(cmd)s\n '
+                      'stdout: %(out)s\n stderr: %(err)s')
+                            % {'msg': str(e),
+                               'cmd': ssh_cmd,
+                               'out': str(out),
+                               'err': str(err)})
+                raise exception.VolumeBackendAPIException(
+                        data=exception_message)
+
+            if port_node_id in storage_nodes:
+                node = storage_nodes[port_node_id]
+                if len(port_ipv4) > 0:
+                    node['ipv4'].append(port_ipv4)
+                if len(port_ipv6) > 0:
+                    node['ipv6'].append(port_ipv6)
+            else:
+                raise exception.VolumeBackendAPIException(
+                        data=_('check_for_setup_error: '
+                               'fail to storage configuration: unknown '
+                               'storage node %(node_id)s from CLI output.\n '
+                                'stdout: %(out)s\n stderr: %(err)s\n')
+                              % {'node_id': port_node_id,
+                                 'out': str(out),
+                                 'err': str(err)})
+
+        iscsi_ipv4_conf = []
+        iscsi_ipv6_conf = []
+        for node_key in storage_nodes:
+            node = storage_nodes[node_key]
+            if 'ipv4' in node and len(node['iscsi_name']) > 0:
+                iscsi_ipv4_conf.append({'iscsi_name': node['iscsi_name'],
+                                        'ip': node['ipv4'],
+                                        'node_id': node['id']})
+            if 'ipv6' in node and len(node['iscsi_name']) > 0:
+                iscsi_ipv6_conf.append({'iscsi_name': node['iscsi_name'],
+                                        'ip': node['ipv6'],
+                                        'node_id': node['id']})
+            if (len(node['ipv4']) == 0) and (len(node['ipv6']) == 0):
+                raise exception.VolumeBackendAPIException(
+                        data=_('check_for_setup_error: '
+                                'fail to storage configuration: storage '
+                                'node %s has no IP addresses configured')
+                                % node['id'])
+
+        # Make sure we have at least one IPv4 address with a iSCSI name
+        # TODO(ronenkat) need to expand this to support IPv6
+        self._driver_assert(len(iscsi_ipv4_conf) > 0,
+            _('could not obtain IP address and iSCSI name from the storage. '
+              'Please verify that the storage is configured for iSCSI.\n '
+              'Storage nodes: %(nodes)s\n portips: %(portips)s')
+                % {'nodes': nodes, 'portips': portips})
+
+        self.iscsi_ipv4_conf = iscsi_ipv4_conf
+        self.iscsi_ipv6_conf = iscsi_ipv6_conf
+
+        LOG.debug(_('leave: check_for_setup_error'))
+
+    def _check_num_perc(self, value):
+        """Return True if value is either a number or a percentage."""
+        if value.endswith('%'):
+            value = value[0:-1]
+        return value.isdigit()
+
+    def _check_flags(self):
+        """Ensure that the flags are set properly."""
+
+        required_flags = ['san_ip', 'san_ssh_port', 'san_login',
+                          'storwize_svc_volpool_name']
+        for flag in required_flags:
+            if not getattr(FLAGS, flag, None):
+                raise exception.InvalidInput(
+                        reason=_('%s is not set') % flag)
+
+        # Ensure that either password or keyfile were set
+        if not (getattr(FLAGS, 'san_password', None)
+                or getattr(FLAGS, 'san_private_key', None)):
+            raise exception.InvalidInput(
+                reason=_('Password or SSH private key is required for '
+                         'authentication: set either san_password or '
+                         'san_private_key option'))
+
+        # Check that rsize is a number or percentage
+        rsize = getattr(FLAGS, 'storwize_svc_vol_rsize')
+        if not self._check_num_perc(rsize) and (rsize != '-1'):
+            raise exception.InvalidInput(
+                reason=_('Illegal value specified for storwize_svc_vol_rsize: '
+                         'set to either a number or a percentage'))
+
+        # Check that warning is a number or percentage
+        warning = getattr(FLAGS, 'storwize_svc_vol_warning')
+        if not self._check_num_perc(warning):
+            raise exception.InvalidInput(
+                reason=_('Illegal value specified for '
+                         'storwize_svc_vol_warning: '
+                         'set to either a number or a percentage'))
+
+        # Check that autoexpand is a boolean
+        autoexpand = getattr(FLAGS, 'storwize_svc_vol_autoexpand')
+        if type(autoexpand) != type(True):
+            raise exception.InvalidInput(
+                reason=_('Illegal value specified for '
+                         'storwize_svc_vol_autoexpand: set to either '
+                         'True or False'))
+
+        # Check that grainsize is 32/64/128/256
+        grainsize = getattr(FLAGS, 'storwize_svc_vol_grainsize')
+        if grainsize not in ['32', '64', '128', '256']:
+            raise exception.InvalidInput(
+                reason=_('Illegal value specified for '
+                         'storwize_svc_vol_grainsize: set to either '
+                         '\'32\', \'64\', \'128\', or \'256\''))
+
+        # Check that flashcopy_timeout is numeric and 32/64/128/256
+        flashcopy_timeout = getattr(FLAGS, 'storwize_svc_flashcopy_timeout')
+        if not (flashcopy_timeout.isdigit() and int(flashcopy_timeout) > 0 and
+            int(flashcopy_timeout) <= 600):
+            raise exception.InvalidInput(
+                reason=_('Illegal value %s specified for '
+                         'storwize_svc_flashcopy_timeout: '
+                         'valid values are between 0 and 600')
+                                         % flashcopy_timeout)
+
+        # Check that compression is a boolean and that rsize is set
+        volume_compression = getattr(FLAGS, 'storwize_svc_vol_compression')
+        if type(volume_compression) != type(True):
+            raise exception.InvalidInput(
+                reason=_('Illegal value specified for '
+                         'storwize_svc_vol_compression: set to either '
+                         'True or False'))
+        if ((volume_compression == True) and
+                (getattr(FLAGS, 'storwize_svc_vol_rsize') == '-1')):
+            raise exception.InvalidInput(
+                reason=_('If compression is set to True, rsize must '
+                         'also be set (not equal to -1)'))
+
+        # Check that easytier is a boolean
+        volume_easytier = getattr(FLAGS, 'storwize_svc_vol_easytier')
+        if type(volume_easytier) != type(True):
+            raise exception.InvalidInput(
+                reason=_('Illegal value specified for '
+                         'storwize_svc_vol_easytier: set to either '
+                         'True or False'))
+
+    def do_setup(self, context):
+        """Validate the flags."""
+        LOG.debug(_('enter: do_setup'))
+        self._check_flags()
+        LOG.debug(_('leave: do_setup'))
+
+    def create_volume(self, volume):
+        """Create a new volume - uses the internal method."""
+        return self._create_volume(volume, units='gb')
+
+    def _create_volume(self, volume, units='gb'):
+        """Create a new volume."""
+
+        name = volume['name']
+        model_update = None
+
+        LOG.debug(_('enter: create_volume: volume %s ') % name)
+
+        size = int(volume['size'])
+
+        if getattr(FLAGS, 'storwize_svc_vol_autoexpand') == True:
+            autoex = '-autoexpand'
+        else:
+            autoex = ''
+
+        if getattr(FLAGS, 'storwize_svc_vol_easytier') == True:
+            easytier = '-easytier on'
+        else:
+            easytier = '-easytier off'
+
+        # Set space-efficient options
+        if getattr(FLAGS, 'storwize_svc_vol_rsize').strip() == '-1':
+            ssh_cmd_se_opt = ''
+        else:
+            ssh_cmd_se_opt = ('-rsize %(rsize)s %(autoex)s -warning %(warn)s' %
+                        {'rsize': getattr(FLAGS, 'storwize_svc_vol_rsize'),
+                         'autoex': autoex,
+                         'warn': getattr(FLAGS, 'storwize_svc_vol_warning')})
+            if getattr(FLAGS, 'storwize_svc_vol_compression'):
+                ssh_cmd_se_opt = ssh_cmd_se_opt + ' -compressed'
+            else:
+                ssh_cmd_se_opt = ssh_cmd_se_opt + (' -grainsize %(grain)s' %
+                       {'grain': getattr(FLAGS, 'storwize_svc_vol_grainsize')})
+
+        ssh_cmd = ('mkvdisk -name %(name)s -mdiskgrp %(mdiskgrp)s '
+                    '-iogrp 0 -size %(size)s -unit '
+                    '%(unit)s %(easytier)s %(ssh_cmd_se_opt)s'
+                    % {'name': name,
+                    'mdiskgrp': getattr(FLAGS, 'storwize_svc_volpool_name'),
+                    'size': size, 'unit': units, 'easytier': easytier,
+                    'ssh_cmd_se_opt': ssh_cmd_se_opt})
+        out, err = self._run_ssh(ssh_cmd)
+        self._driver_assert(len(out.strip()) > 0,
+            _('create volume %(name)s - did not find '
+              'success message in CLI output.\n '
+              'stdout: %(out)s\n stderr: %(err)s')
+                % {'name': name, 'out': str(out), 'err': str(err)})
+
+        # Ensure that the output is as expected
+        match_obj = re.search('Virtual Disk, id \[([0-9]+)\], '
+                                'successfully created', out)
+        # Make sure we got a "successfully created" message with vdisk id
+        self._driver_assert(match_obj is not None,
+            _('create volume %(name)s - did not find '
+              'success message in CLI output.\n '
+              'stdout: %(out)s\n stderr: %(err)s')
+                % {'name': name, 'out': str(out), 'err': str(err)})
+
+        LOG.debug(_('leave: create_volume: volume %(name)s ') % {'name': name})
+
+    def delete_volume(self, volume):
+        self._delete_volume(volume, False)
+
+    def _delete_volume(self, volume, force_opt):
+        """Driver entry point for destroying existing volumes."""
+
+        name = volume['name']
+        LOG.debug(_('enter: delete_volume: volume %(name)s ') % {'name': name})
+
+        if force_opt:
+            force_flag = '-force'
+        else:
+            force_flag = ''
+
+        volume_defined = self._is_volume_defined(name)
+        # Try to delete volume only if found on the storage
+        if volume_defined:
+            out, err = self._run_ssh('rmvdisk %(force)s %(name)s'
+                                    % {'force': force_flag,
+                                       'name': name})
+            # No output should be returned from rmvdisk
+            self._driver_assert(len(out.strip()) == 0,
+                _('delete volume %(name)s - non empty output from CLI.\n '
+                  'stdout: %(out)s\n stderr: %(err)s')
+                                % {'name': name,
+                                   'out': str(out),
+                                   'err': str(err)})
+        else:
+            # Log that volume does not exist
+            LOG.info(_('warning: tried to delete volume %(name)s but '
+                       'it does not exist.') % {'name': name})
+
+        LOG.debug(_('leave: delete_volume: volume %(name)s ') % {'name': name})
+
+    def ensure_export(self, context, volume):
+        """Check that the volume exists on the storage.
+
+        The system does not "export" volumes as a Linux iSCSI target does,
+        and therefore we just check that the volume exists on the storage.
+        """
+        volume_defined = self._is_volume_defined(volume['name'])
+        if not volume_defined:
+            LOG.error(_('ensure_export: volume %s not found on storage')
+                       % volume['name'])
+
+    def create_export(self, context, volume):
+        model_update = None
+        return model_update
+
+    def remove_export(self, context, volume):
+        pass
+
+    def check_for_export(self, context, volume_id):
+        raise NotImplementedError()
+
+    def initialize_connection(self, volume, connector):
+        """Perform the necessary work so that an iSCSI connection can be made.
+
+        To be able to create an iSCSI connection from a given iSCSI name to a
+        volume, we must:
+        1. Translate the given iSCSI name to a host name
+        2. Create new host on the storage system if it does not yet exist
+        2. Map the volume to the host if it is not already done
+        3. Return iSCSI properties, including the IP address of the preferred
+           node for this volume and the LUN number.
+        """
+        LOG.debug(_('enter: initialize_connection: volume %(vol)s with '
+                    'connector %(conn)s') % {'vol': str(volume),
+                    'conn': str(connector)})
+
+        initiator_name = connector['initiator']
+        volume_name = volume['name']
+
+        host_name = self._get_host_from_iscsiname(initiator_name)
+        # Check if a host is defined for the iSCSI initiator name
+        if host_name is None:
+            # Host does not exist - add a new host to Storwize/SVC
+            host_name = self._create_new_host('host%s' % initiator_name,
+                                               initiator_name)
+            # Verify that create_new_host succeeded
+            self._driver_assert(host_name is not None,
+                _('_create_new_host failed to return the host name.'))
+
+        lun_id = self._map_vol_to_host(volume_name, host_name)
+
+        # Get preferred path
+        # Only IPv4 for now because lack of OpenStack support
+        # TODO(ronenkat): Add support for IPv6
+        volume_attributes = self._get_volume_attributes(volume_name)
+        if (volume_attributes is not None and
+            'preferred_node_id' in volume_attributes):
+            preferred_node = volume_attributes['preferred_node_id']
+            preferred_node_entry = None
+            for node in self.iscsi_ipv4_conf:
+                if node['node_id'] == preferred_node:
+                    preferred_node_entry = node
+                    break
+            if preferred_node_entry is None:
+                preferred_node_entry = self.iscsi_ipv4_conf[0]
+                LOG.error(_('initialize_connection: did not find preferred '
+                            'node %(node)s for volume %(vol)s in iSCSI '
+                            'configuration') % {'node': preferred_node,
+                            'vol': volume_name})
+        else:
+            # Get 1st node
+            preferred_node_entry = self.iscsi_ipv4_conf[0]
+            LOG.error(
+                _('initialize_connection: did not find a preferred node '
+                  'for volume %s in iSCSI configuration') % volume_name)
+
+        properties = {}
+        # We didn't use iSCSI discover, as in server-based iSCSI
+        properties['target_discovered'] = False
+        # We take the first IP address for now. Ideally, OpenStack will
+        # support multipath for improved performance.
+        properties['target_portal'] = ('%s:%s' %
+                (preferred_node_entry['ip'][0], '3260'))
+        properties['target_iqn'] = preferred_node_entry['iscsi_name']
+        properties['target_lun'] = lun_id
+        properties['volume_id'] = volume['id']
+
+        LOG.debug(_('leave: initialize_connection:\n volume: %(vol)s\n '
+                    'connector %(conn)s\n properties: %(prop)s')
+                  % {'vol': str(volume),
+                    'conn': str(connector),
+                    'prop': str(properties)})
+
+        return {'driver_volume_type': 'iscsi', 'data': properties, }
+
+    def terminate_connection(self, volume, connector):
+        """Cleanup after an iSCSI connection has been terminated.
+
+        When we clean up a terminated connection between a given iSCSI name
+        and volume, we:
+        1. Translate the given iSCSI name to a host name
+        2. Remove the volume-to-host mapping if it exists
+        3. Delete the host if it has no more mappings (hosts are created
+           automatically by this driver when mappings are created)
+        """
+        LOG.debug(_('enter: terminate_connection: volume %(vol)s with '
+                    'connector %(conn)s') % {'vol': str(volume),
+                    'conn': str(connector)})
+
+        vol_name = volume['name']
+        initiator_name = connector['initiator']
+        host_name = self._get_host_from_iscsiname(initiator_name)
+        # Verify that _get_host_from_iscsiname returned the host.
+        # This should always succeed as we terminate an existing connection.
+        self._driver_assert(host_name is not None,
+            _('_get_host_from_iscsiname failed to return the host name '
+              'for iscsi name %s') % initiator_name)
+
+        # Check if vdisk-host mapping exists, remove if it does
+        mapping_data = self._get_hostvdisk_mappings(host_name)
+        if vol_name in mapping_data:
+            out, err = self._run_ssh('rmvdiskhostmap -host %s %s'
+                                     % (host_name, vol_name))
+            # Verify CLI behaviour - no output is returned from
+            # rmvdiskhostmap
+            self._driver_assert(len(out.strip()) == 0,
+                _('delete mapping of volume %(vol)s to host %(host)s '
+                  '- non empty output from CLI.\n '
+                  'stdout: %(out)s\n stderr: %(err)s')
+                                 % {'vol': vol_name,
+                                    'host': host_name,
+                                    'out': str(out),
+                                    'err': str(err)})
+            del mapping_data[vol_name]
+        else:
+            LOG.error(_('terminate_connection: no mapping of volume '
+                        '%(vol)s to host %(host)s found') %
+                        {'vol': vol_name, 'host': host_name})
+
+        # If this host has no more mappings, delete it
+        if not mapping_data:
+            self._delete_host(host_name)
+
+        LOG.debug(_('leave: terminate_connection: volume %(vol)s with '
+                    'connector %(conn)s') % {'vol': str(volume),
+                    'conn': str(connector)})
+
+    def _flashcopy_cleanup(self, fc_map_id, source, target):
+        """Clean up a failed FlashCopy operation."""
+
+        try:
+            out, err = self._run_ssh('stopfcmap -force %s' % fc_map_id)
+            out, err = self._run_ssh('rmfcmap -force %s' % fc_map_id)
+        except exception.ProcessExecutionError as e:
+            LOG.error(_('_run_flashcopy: fail to cleanup failed FlashCopy '
+                        'mapping %(fc_map_id)% '
+                        'from %(source)s to %(target)s.\n'
+                        'stdout: %(out)s\n stderr: %(err)s')
+                        % {'fc_map_id': fc_map_id,
+                           'source': source,
+                           'target': target,
+                           'out': e.stdout,
+                           'err': e.stderr})
+
+    def _run_flashcopy(self, source, target):
+        """Create a FlashCopy mapping from the source to the target."""
+
+        LOG.debug(
+            _('enter: _run_flashcopy: execute FlashCopy from source '
+              '%(source)s to target %(target)s') % {'source': source,
+              'target': target})
+
+        fc_map_cli_cmd = ('mkfcmap -source %s -target %s -autodelete '
+                            '-cleanrate 0' % (source, target))
+        out, err = self._run_ssh(fc_map_cli_cmd)
+        self._driver_assert(len(out.strip()) > 0,
+            _('create FC mapping from %(source)s to %(target)s - '
+              'did not find success message in CLI output.\n'
+              ' stdout: %(out)s\n stderr: %(err)s\n')
+                            % {'source': source,
+                                'target': target,
+                                'out': str(out),
+                                'err': str(err)})
+
+        # Ensure that the output is as expected
+        match_obj = re.search('FlashCopy Mapping, id \[([0-9]+)\], '
+                                'successfully created', out)
+        # Make sure we got a "successfully created" message with vdisk id
+        self._driver_assert(match_obj is not None,
+            _('create FC mapping from %(source)s to %(target)s - '
+              'did not find success message in CLI output.\n'
+              ' stdout: %(out)s\n stderr: %(err)s\n')
+                            % {'source': source,
+                               'target': target,
+                               'out': str(out),
+                               'err': str(err)})
+
+        try:
+            fc_map_id = match_obj.group(1)
+            self._driver_assert(fc_map_id is not None,
+                _('create FC mapping from %(source)s to %(target)s - '
+                  'did not find mapping id in CLI output.\n'
+                  ' stdout: %(out)s\n stderr: %(err)s\n')
+                            % {'source': source,
+                               'target': target,
+                               'out': str(out),
+                               'err': str(err)})
+        except IndexError:
+            self._driver_assert(False,
+                _('create FC mapping from %(source)s to %(target)s - '
+                  'did not find mapping id in CLI output.\n'
+                  ' stdout: %(out)s\n stderr: %(err)s\n')
+                            % {'source': source,
+                               'target': target,
+                               'out': str(out),
+                               'err': str(err)})
+        try:
+            out, err = self._run_ssh('prestartfcmap %s' % fc_map_id)
+        except exception.ProcessExecutionError as e:
+            with excutils.save_and_reraise_exception():
+                LOG.error(_('_run_flashcopy: fail to prepare FlashCopy '
+                            'from %(source)s to %(target)s.\n'
+                            'stdout: %(out)s\n stderr: %(err)s')
+                            % {'source': source,
+                               'target': target,
+                               'out': e.stdout,
+                               'err': e.stderr})
+                self._flashcopy_cleanup(fc_map_id, source, target)
+
+        mapping_ready = False
+        wait_time = 5
+        # Allow waiting of up to timeout (set as parameter)
+        max_retries = (int(getattr(FLAGS,
+                        'storwize_svc_flashcopy_timeout')) / wait_time) + 1
+        for try_number in range(1, max_retries):
+            mapping_attributes = self._get_flashcopy_mapping_attributes(
+                                                            fc_map_id)
+            if (mapping_attributes is None or
+                    'status' not in mapping_attributes):
+                break
+            if mapping_attributes['status'] == 'prepared':
+                mapping_ready = True
+                break
+            elif mapping_attributes['status'] != 'preparing':
+                # Unexpected mapping status
+                exception_msg = (_('unexecpted mapping status %(status)s '
+                                   'for mapping %(id)s. Attributes: '
+                                   '%(attr)s')
+                                 % {'status': mapping_attributes['status'],
+                                    'id': fc_map_id,
+                                    'attr': mapping_attributes})
+                raise exception.VolumeBackendAPIException(
+                        data=exception_msg)
+            # Need to wait for mapping to be prepared, wait a few seconds
+            time.sleep(wait_time)
+
+        if not mapping_ready:
+            exception_msg = (_('mapping %(id)s prepare failed to complete '
+                               'within the alloted %(to)s seconds timeout. '
+                               'Terminating') % {'id': fc_map_id,
+                               'to': getattr(
+                                FLAGS, 'storwize_svc_flashcopy_timeout')})
+            LOG.error(_('_run_flashcopy: fail to start FlashCopy '
+                        'from %(source)s to %(target)s with '
+                        'exception %(ex)s')
+                        % {'source': source,
+                           'target': target,
+                           'ex': exception_msg})
+            self._flashcopy_cleanup(fc_map_id, source, target)
+            raise exception.InvalidSnapshot(
+                reason=_('_run_flashcopy: %s') % exception_msg)
+
+        try:
+            out, err = self._run_ssh('startfcmap %s' % fc_map_id)
+        except exception.ProcessExecutionError as e:
+            with excutils.save_and_reraise_exception():
+                LOG.error(_('_run_flashcopy: fail to start FlashCopy '
+                            'from %(source)s to %(target)s.\n'
+                            'stdout: %(out)s\n stderr: %(err)s')
+                            % {'source': source,
+                               'target': target,
+                               'out': e.stdout,
+                               'err': e.stderr})
+                self._flashcopy_cleanup(fc_map_id, source, target)
+
+        LOG.debug(_('leave: _run_flashcopy: FlashCopy started from '
+                    '%(source)s to %(target)s') % {'source': source,
+                    'target': target})
+
+    def create_volume_from_snapshot(self, volume, snapshot):
+        """Create a new snapshot from volume."""
+
+        source_volume = snapshot['name']
+        tgt_volume = volume['name']
+
+        LOG.debug(_('enter: create_volume_from_snapshot: snapshot %(tgt)s '
+                    'from volume %(src)s') % {'tgt': tgt_volume,
+                    'src': source_volume})
+
+        src_volume_attributes = self._get_volume_attributes(source_volume)
+        if src_volume_attributes is None:
+            exception_msg = (_('create_volume_from_snapshot: source volume %s '
+                               'does not exist') % source_volume)
+            LOG.error(exception_msg)
+            raise exception.SnapshotNotFound(exception_msg,
+                                           volume_id=source_volume)
+
+        self._driver_assert('capacity' in src_volume_attributes,
+                _('create_volume_from_snapshot: cannot get source '
+                  'volume %(src)s capacity from volume attributes '
+                  '%(attr)s') % {'src': source_volume,
+                                 'attr': src_volume_attributes})
+        src_volume_size = src_volume_attributes['capacity']
+
+        tgt_volume_attributes = self._get_volume_attributes(tgt_volume)
+        # Does the snapshot target exist?
+        if tgt_volume_attributes is not None:
+            exception_msg = (_('create_volume_from_snapshot: target volume %s '
+                               'already exists, cannot create') % tgt_volume)
+            LOG.error(exception_msg)
+            raise exception.InvalidSnapshot(reason=exception_msg)
+
+        snapshot_volume = {}
+        snapshot_volume['name'] = tgt_volume
+        snapshot_volume['size'] = src_volume_size
+
+        self._create_volume(snapshot_volume, units='b')
+
+        try:
+            self._run_flashcopy(source_volume, tgt_volume)
+        except Exception:
+            with excutils.save_and_reraise_exception():
+                # Clean up newly-created snapshot if the FlashCopy failed
+                self._delete_volume(snapshot_volume, True)
+
+        LOG.debug(
+            _('leave: create_volume_from_snapshot: %s created successfully')
+            % tgt_volume)
+
+    def create_snapshot(self, snapshot):
+        """Create a new snapshot using FlashCopy."""
+
+        src_volume = snapshot['volume_name']
+        tgt_volume = snapshot['name']
+
+        # Flag to keep track of created volumes in case FlashCopy
+        tgt_volume_created = False
+
+        LOG.debug(_('enter: create_snapshot: snapshot %(tgt)s from '
+                    'volume %(src)s') % {'tgt': tgt_volume,
+                    'src': src_volume})
+
+        src_volume_attributes = self._get_volume_attributes(src_volume)
+        if src_volume_attributes is None:
+            exception_msg = (
+                _('create_snapshot: source volume %s does not exist')
+                % src_volume)
+            LOG.error(exception_msg)
+            raise exception.VolumeNotFound(exception_msg,
+                                           volume_id=src_volume)
+
+        self._driver_assert('capacity' in src_volume_attributes,
+                _('create_volume_from_snapshot: cannot get source '
+                  'volume %(src)s capacity from volume attributes '
+                  '%(attr)s') % {'src': src_volume,
+                                 'attr': src_volume_attributes})
+
+        source_volume_size = src_volume_attributes['capacity']
+
+        tgt_volume_attributes = self._get_volume_attributes(tgt_volume)
+        # Does the snapshot target exist?
+        snapshot_volume = {}
+        if tgt_volume_attributes is None:
+            # No, create a new snapshot volume
+            snapshot_volume['name'] = tgt_volume
+            snapshot_volume['size'] = source_volume_size
+            self._create_volume(snapshot_volume, units='b')
+            tgt_volume_created = True
+        else:
+            # Yes, target exists, verify exact same size as source
+            self._driver_assert('capacity' in tgt_volume_attributes,
+                    _('create_volume_from_snapshot: cannot get source '
+                      'volume %(src)s capacity from volume attributes '
+                      '%(attr)s') % {'src': tgt_volume,
+                                     'attr': tgt_volume_attributes})
+            target_volume_size = tgt_volume_attributes['capacity']
+            if target_volume_size != source_volume_size:
+                exception_msg = (
+                    _('create_snapshot: source %(src)s and target '
+                      'volume %(tgt)s have different capacities '
+                      '(source:%(ssize)s target:%(tsize)s)') %
+                        {'src': src_volume,
+                         'tgt': tgt_volume,
+                         'ssize': source_volume_size,
+                         'tsize': target_volume_size})
+                LOG.error(exception_msg)
+                raise exception.InvalidSnapshot(reason=exception_msg)
+
+        try:
+            self._run_flashcopy(src_volume, tgt_volume)
+        except exception.InvalidSnapshot:
+            with excutils.save_and_reraise_exception():
+                # Clean up newly-created snapshot if the FlashCopy failed
+                if tgt_volume_created:
+                    self._delete_volume(snapshot_volume, True)
+
+        LOG.debug(_('leave: create_snapshot: %s created successfully')
+                  % tgt_volume)
+
+    def delete_snapshot(self, snapshot):
+        self._delete_snapshot(snapshot, False)
+
+    def _delete_snapshot(self, snapshot, force_opt):
+        """Delete a snapshot from the storage."""
+        LOG.debug(_('enter: delete_snapshot: snapshot %s') % snapshot)
+
+        snapshot_defined = self._is_volume_defined(snapshot['name'])
+        if snapshot_defined:
+            if force_opt:
+                self._delete_volume(snapshot, force_opt)
+            else:
+                self.delete_volume(snapshot)
+
+        LOG.debug(_('leave: delete_snapshot: snapshot %s') % snapshot)
+
+    def _get_host_from_iscsiname(self, iscsi_name):
+        """List the hosts defined in the storage.
+
+        Return the host name with the given iSCSI name, or None if there is
+        no host name with that iSCSI name.
+        """
+
+        LOG.debug(_('enter: _get_host_from_iscsiname: iSCSI initiator %s')
+                   % iscsi_name)
+
+        # Get list of host in the storage
+        ssh_cmd = 'lshost -delim !'
+        out, err = self._run_ssh(ssh_cmd)
+
+        if (len(out.strip()) == 0):
+            return None
+
+        err_msg = _('_get_host_from_iscsiname: '
+              'failed with unexpected CLI output.\n'
+              ' command: %(cmd)s\n stdout: %(out)s\n '
+              'stderr: %(err)s') % {'cmd': ssh_cmd,
+                                    'out': str(out),
+                                    'err': str(err)}
+        host_lines = out.strip().split('\n')
+        self._driver_assert(len(host_lines) > 0, err_msg)
+        header = host_lines.pop(0).split('!')
+        self._driver_assert('name' in header, err_msg)
+        name_index = header.index('name')
+
+        hosts = map(lambda x: x.split('!')[name_index], host_lines)
+        hostname = None
+
+        # For each host, get its details and check for its iSCSI name
+        for host in hosts:
+            ssh_cmd = 'lshost -delim ! %s' % host
+            out, err = self._run_ssh(ssh_cmd)
+            self._driver_assert(len(out) > 0,
+                    _('_get_host_from_iscsiname: '
+                      'Unexpected response from CLI output. '
+                      'Command: %(cmd)s\n stdout: %(out)s\n stderr: %(err)s')
+                        % {'cmd': ssh_cmd,
+                           'out': str(out),
+                           'err': str(err)})
+            for attrib_line in out.split('\n'):
+                # If '!' not found, return the string and two empty strings
+                attrib_name, foo, attrib_value = attrib_line.partition('!')
+                if attrib_name == 'iscsi_name':
+                    if iscsi_name == attrib_value:
+                        hostname = host
+                        break
+            if hostname is not None:
+                break
+
+        LOG.debug(_('leave: _get_host_from_iscsiname: iSCSI initiator %s')
+                   % iscsi_name)
+
+        return hostname
+
+    def _create_new_host(self, host_name, initiator_name):
+        """Create a new host on the storage system.
+
+        We modify the given host name, replace any invalid characters and
+        adding a random suffix to avoid conflicts due to the translation. The
+        host is associated with the given iSCSI initiator name.
+        """
+
+        LOG.debug(_('enter: _create_new_host: host %(name)s with iSCSI '
+                    'initiator %(init)s') % {'name': host_name,
+                    'init': initiator_name})
+
+        if isinstance(host_name, unicode):
+            host_name = host_name.translate(self._unicode_host_name_filter)
+        elif isinstance(host_name, str):
+            host_name = host_name.translate(self._string_host_name_filter)
+        else:
+            msg = _('_create_new_host: cannot clean host name. Host name '
+                    'is not unicode or string')
+            LOG.error(msg)
+            raise exception.NoValidHost(reason=msg)
+
+        # Add 5 digit random suffix to the host name to avoid
+        # conflicts in host names after removing invalid characters
+        # for Storwize/SVC names
+        host_name = '%s_%s' % (host_name, random.randint(10000, 99999))
+        out, err = self._run_ssh('mkhost -name "%s" -iscsiname "%s"'
+                                 % (host_name, initiator_name))
+        self._driver_assert(len(out.strip()) > 0 and
+                            'successfully created' in out,
+                _('create host %(name)s with iSCSI initiator %(init)s - '
+                  'did not find success message in CLI output.\n '
+                  'stdout: %(out)s\n stderr: %(err)s\n')
+                  % {'name': host_name,
+                     'init': initiator_name,
+                     'out': str(out),
+                     'err': str(err)})
+
+        LOG.debug(_('leave: _create_new_host: host %(host)s with iSCSI '
+                    'initiator %(init)s') % {'host': host_name,
+                    'init': initiator_name})
+
+        return host_name
+
+    def _delete_host(self, host_name):
+        """Delete a host and associated iSCSI initiator name."""
+
+        LOG.debug(_('enter: _delete_host: host %s ') % host_name)
+
+        # Check if host exists on system, expect to find the host
+        is_defined = self._is_host_defined(host_name)
+        if is_defined:
+            # Delete host
+            out, err = self._run_ssh('rmhost %s ' % host_name)
+        else:
+            LOG.info(_('warning: tried to delete host %(name)s but '
+                       'it does not exist.') % {'name': host_name})
+
+        LOG.debug(_('leave: _delete_host: host %s ') % host_name)
+
+    def _is_volume_defined(self, volume_name):
+        """Check if volume is defined."""
+        LOG.debug(_('enter: _is_volume_defined: volume %s ') % volume_name)
+        volume_attributes = self._get_volume_attributes(volume_name)
+        LOG.debug(_('leave: _is_volume_defined: volume %(vol)s with %(str)s ')
+                   % {'vol': volume_name,
+                   'str': volume_attributes is not None})
+        if volume_attributes is None:
+            return False
+        else:
+            return True
+
+    def _is_host_defined(self, host_name):
+        """Check if a host is defined on the storage."""
+
+        LOG.debug(_('enter: _is_host_defined: host %s ') % host_name)
+
+        # Get list of hosts with the name %host_name%
+        # We expect zero or one line if host does not exist,
+        # two lines if it does exist, otherwise error
+        out, err = self._run_ssh('lshost -filtervalue name=%s -delim !'
+                                % host_name)
+        if len(out.strip()) == 0:
+            return False
+
+        lines = out.strip().split('\n')
+        self._driver_assert(len(lines) <= 2,
+                _('_is_host_defined: Unexpected response from CLI output.\n '
+                  'stdout: %(out)s\n stderr: %(err)s\n')
+                % {'out': str(out),
+                   'err': str(err)})
+
+        if len(lines) == 2:
+            host_info = self._get_hdr_dic(lines[0], lines[1], '!')
+            host_name_from_storage = host_info['name']
+            # Make sure we got the data for the right host
+            self._driver_assert(host_name_from_storage == host_name,
+                    _('Data received for host %(host1)s instead of host '
+                      '%(host2)s.\n '
+                      'stdout: %(out)s\n stderr: %(err)s\n')
+                      % {'host1': host_name_from_storage,
+                         'host2': host_name,
+                         'out': str(out),
+                         'err': str(err)})
+        else:  # 0 or 1 lines
+            host_name_from_storage = None
+
+        LOG.debug(_('leave: _is_host_defined: host %(host)s with %(str)s ') % {
+                   'host': host_name,
+                   'str': host_name_from_storage is not None})
+
+        if host_name_from_storage is None:
+            return False
+        else:
+            return True
+
+    def _get_hostvdisk_mappings(self, host_name):
+        """Return the defined storage mappings for a host."""
+
+        return_data = {}
+        ssh_cmd = 'lshostvdiskmap -delim ! %s' % host_name
+        out, err = self._run_ssh(ssh_cmd)
+
+        mappings = out.strip().split('\n')
+        if len(mappings) > 0:
+            header = mappings.pop(0)
+            for mapping_line in mappings:
+                mapping_data = self._get_hdr_dic(header, mapping_line, '!')
+                return_data[mapping_data['vdisk_name']] = mapping_data
+
+        return return_data
+
+    def _map_vol_to_host(self, volume_name, host_name):
+        """Create a mapping between a volume to a host."""
+
+        LOG.debug(_('enter: _map_vol_to_host: volume %(vol)s to '
+                    'host %(host)s') % {'vol': volume_name,
+                    'host': host_name})
+
+        # Check if this volume is already mapped to this host
+        mapping_data = self._get_hostvdisk_mappings(host_name)
+
+        mapped_flag = False
+        result_lun = '-1'
+        if volume_name in mapping_data:
+            mapped_flag = True
+            result_lun = mapping_data[volume_name]['SCSI_id']
+        else:
+            lun_used = []
+            for k, v in mapping_data.iteritems():
+                lun_used.append(int(v['SCSI_id']))
+            lun_used.sort()
+            # Assume all luns are taken to this point, and then try to find
+            # an unused one
+            result_lun = str(len(lun_used))
+            for index, n in enumerate(lun_used):
+                if n > index:
+                    result_lun = str(index)
+
+        # Volume is not mapped to host, create a new LUN
+        if not mapped_flag:
+            out, err = self._run_ssh('mkvdiskhostmap -host %s -scsi %s %s'
+                                    % (host_name, result_lun, volume_name))
+            self._driver_assert(len(out.strip()) > 0 and
+                                'successfully created' in out,
+                    _('_map_vol_to_host: mapping host %(host)s to '
+                      'volume %(vol)s with LUN '
+                      '%(lun)s - did not find success message in CLI output. '
+                      'stdout: %(out)s\n stderr: %(err)s\n')
+                    % {'host': host_name,
+                      'vol': volume_name,
+                      'lun': result_lun,
+                      'out': str(out),
+                      'err': str(err)})
+
+        LOG.debug(_('leave: _map_vol_to_host: LUN %(lun)s, volume %(vol)s, '
+                    'host %(host)s') % {'lun': result_lun, 'vol': volume_name,
+                    'host': host_name})
+
+        return result_lun
+
+    def _get_flashcopy_mapping_attributes(self, fc_map_id):
+        """Return the attributes of a FlashCopy mapping.
+
+        Returns the attributes for the specified FlashCopy mapping, or
+        None if the mapping does not exist.
+        An exception is raised if the information from system can not
+        be parsed or matched to a single FlashCopy mapping (this case
+        should not happen under normal conditions).
+        """
+
+        LOG.debug(_('enter: _get_flashcopy_mapping_attributes: mapping %s')
+                   % fc_map_id)
+        # Get the lunid to be used
+
+        fc_ls_map_cmd = ('lsfcmap -filtervalue id=%s -delim !' % fc_map_id)
+        out, err = self._run_ssh(fc_ls_map_cmd)
+        self._driver_assert(len(out) > 0,
+            _('_get_flashcopy_mapping_attributes: '
+              'Unexpected response from CLI output. '
+              'Command: %(cmd)s\n stdout: %(out)s\n stderr: %(err)s')
+                % {'cmd': fc_ls_map_cmd,
+                   'out': str(out),
+                   'err': str(err)})
+
+        # Get list of FlashCopy mappings
+        # We expect zero or one line if mapping does not exist,
+        # two lines if it does exist, otherwise error
+        lines = out.strip().split('\n')
+        self._driver_assert(len(lines) <= 2,
+                 _('_get_flashcopy_mapping_attributes: '
+                   'Unexpected response from CLI output. '
+                   'Command: %(cmd)s\n stdout: %(out)s\n stderr: %(err)s')
+                            % {'cmd': fc_ls_map_cmd,
+                               'out': str(out),
+                               'err': str(err)})
+
+        if len(lines) == 2:
+            attributes = self._get_hdr_dic(lines[0], lines[1], '!')
+        else:  # 0 or 1 lines
+            attributes = None
+
+        LOG.debug(_('leave: _get_flashcopy_mapping_attributes: mapping '
+                    '%(id)s, attributes %(attr)s') %
+                   {'id': fc_map_id,
+                    'attr': attributes})
+
+        return attributes
+
+    def _get_volume_attributes(self, volume_name):
+        """Return volume attributes, or None if volume does not exist
+
+        Exception is raised if the information from system can not be
+        parsed/matched to a single volume.
+        """
+
+        LOG.debug(_('enter: _get_volume_attributes: volume %s')
+                   % volume_name)
+        # Get the lunid to be used
+
+        try:
+            ssh_cmd = 'lsvdisk -bytes -delim ! %s ' % volume_name
+            out, err = self._run_ssh(ssh_cmd)
+        except exception.ProcessExecutionError as e:
+            # Didn't get details from the storage, return None
+            LOG.error(_('CLI Exception output:\n command: %(cmd)s\n '
+                        'stdout: %(out)s\n stderr: %(err)s') %
+                      {'cmd': ssh_cmd,
+                       'out': e.stdout,
+                       'err': e.stderr})
+            return None
+
+        self._driver_assert(len(out) > 0,
+                    ('_get_volume_attributes: '
+                      'Unexpected response from CLI output. '
+                      'Command: %(cmd)s\n stdout: %(out)s\n stderr: %(err)s')
+                        % {'cmd': ssh_cmd,
+                           'out': str(out),
+                           'err': str(err)})
+        attributes = {}
+        for attrib_line in out.split('\n'):
+            # If '!' not found, return the string and two empty strings
+            attrib_name, foo, attrib_value = attrib_line.partition('!')
+            if attrib_name is not None and attrib_name.strip() > 0:
+                attributes[attrib_name] = attrib_value
+
+        LOG.debug(_('leave: _get_volume_attributes:\n volume %(vol)s\n '
+                    'attributes: %(attr)s')
+                  % {'vol': volume_name,
+                     'attr': str(attributes)})
+
+        return attributes
